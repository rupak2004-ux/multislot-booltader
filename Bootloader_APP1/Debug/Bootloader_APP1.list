
Bootloader_APP1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000018c  08008000  08008000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         000010d8  0800818c  0800818c  0000118c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000000  08009264  08009264  00003028  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .ARM.extab    00000000  08009264  08009264  00003028  2**0
                  CONTENTS, READONLY
  4 .ARM          00000008  08009264  08009264  00002264  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  0800926c  0800926c  00003028  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  0800926c  0800926c  0000226c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .fini_array   00000004  08009270  08009270  00002270  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .data         00000028  20000000  08009274  00003000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .sram2        00000000  10000000  10000000  00003028  2**0
                  CONTENTS
 10 .bss          00000038  20000028  20000028  00003028  2**2
                  ALLOC
 11 ._user_heap_stack 00000600  20000060  20000060  00003028  2**0
                  ALLOC
 12 .ARM.attributes 0000002a  00000000  00000000  00003028  2**0
                  CONTENTS, READONLY
 13 .debug_info   00001a2d  00000000  00000000  00003052  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000006b9  00000000  00000000  00004a7f  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 000001a8  00000000  00000000  00005138  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00000134  00000000  00000000  000052e0  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  00002716  00000000  00000000  00005414  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   00002071  00000000  00000000  00007b2a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0000a641  00000000  00000000  00009b9b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  000141dc  2**0
                  CONTENTS, READONLY
 21 .debug_frame  000005bc  00000000  00000000  00014220  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 0000005a  00000000  00000000  000147dc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

0800818c <__do_global_dtors_aux>:
 800818c:	b510      	push	{r4, lr}
 800818e:	4c05      	ldr	r4, [pc, #20]	@ (80081a4 <__do_global_dtors_aux+0x18>)
 8008190:	7823      	ldrb	r3, [r4, #0]
 8008192:	b933      	cbnz	r3, 80081a2 <__do_global_dtors_aux+0x16>
 8008194:	4b04      	ldr	r3, [pc, #16]	@ (80081a8 <__do_global_dtors_aux+0x1c>)
 8008196:	b113      	cbz	r3, 800819e <__do_global_dtors_aux+0x12>
 8008198:	4804      	ldr	r0, [pc, #16]	@ (80081ac <__do_global_dtors_aux+0x20>)
 800819a:	f3af 8000 	nop.w
 800819e:	2301      	movs	r3, #1
 80081a0:	7023      	strb	r3, [r4, #0]
 80081a2:	bd10      	pop	{r4, pc}
 80081a4:	20000028 	.word	0x20000028
 80081a8:	00000000 	.word	0x00000000
 80081ac:	0800924c 	.word	0x0800924c

080081b0 <frame_dummy>:
 80081b0:	b508      	push	{r3, lr}
 80081b2:	4b03      	ldr	r3, [pc, #12]	@ (80081c0 <frame_dummy+0x10>)
 80081b4:	b11b      	cbz	r3, 80081be <frame_dummy+0xe>
 80081b6:	4903      	ldr	r1, [pc, #12]	@ (80081c4 <frame_dummy+0x14>)
 80081b8:	4803      	ldr	r0, [pc, #12]	@ (80081c8 <frame_dummy+0x18>)
 80081ba:	f3af 8000 	nop.w
 80081be:	bd08      	pop	{r3, pc}
 80081c0:	00000000 	.word	0x00000000
 80081c4:	2000002c 	.word	0x2000002c
 80081c8:	0800924c 	.word	0x0800924c

080081cc <strlen>:
 80081cc:	4603      	mov	r3, r0
 80081ce:	f813 2b01 	ldrb.w	r2, [r3], #1
 80081d2:	2a00      	cmp	r2, #0
 80081d4:	d1fb      	bne.n	80081ce <strlen+0x2>
 80081d6:	1a18      	subs	r0, r3, r0
 80081d8:	3801      	subs	r0, #1
 80081da:	4770      	bx	lr

080081dc <USART2_Init>:




void USART2_Init(void)
{
 80081dc:	b580      	push	{r7, lr}
 80081de:	af00      	add	r7, sp, #0
	usart_handle.pUSARTx = USART2;
 80081e0:	4b0d      	ldr	r3, [pc, #52]	@ (8008218 <USART2_Init+0x3c>)
 80081e2:	4a0e      	ldr	r2, [pc, #56]	@ (800821c <USART2_Init+0x40>)
 80081e4:	601a      	str	r2, [r3, #0]
	usart_handle.USART_Config_t.USART_BAUD_RATE = USART_STD_BAUD_115200;
 80081e6:	4b0c      	ldr	r3, [pc, #48]	@ (8008218 <USART2_Init+0x3c>)
 80081e8:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
 80081ec:	609a      	str	r2, [r3, #8]
	usart_handle.USART_Config_t.USART_HW_FLOW_CTRL = USART_HW_FLOW_CTRL_NONE;
 80081ee:	4b0a      	ldr	r3, [pc, #40]	@ (8008218 <USART2_Init+0x3c>)
 80081f0:	2200      	movs	r2, #0
 80081f2:	73da      	strb	r2, [r3, #15]
	usart_handle.USART_Config_t.USART_MODE = USART_MODE_TXRX;
 80081f4:	4b08      	ldr	r3, [pc, #32]	@ (8008218 <USART2_Init+0x3c>)
 80081f6:	2202      	movs	r2, #2
 80081f8:	711a      	strb	r2, [r3, #4]
	usart_handle.USART_Config_t.USART_STOP_BITS = USART_STOP_BIT_1;
 80081fa:	4b07      	ldr	r3, [pc, #28]	@ (8008218 <USART2_Init+0x3c>)
 80081fc:	2200      	movs	r2, #0
 80081fe:	731a      	strb	r2, [r3, #12]
	usart_handle.USART_Config_t.USART_WORD_LEN = USART_WORDLEN_8BITS;
 8008200:	4b05      	ldr	r3, [pc, #20]	@ (8008218 <USART2_Init+0x3c>)
 8008202:	2200      	movs	r2, #0
 8008204:	735a      	strb	r2, [r3, #13]
	usart_handle.USART_Config_t.USART_PARITY = USART_PARITY_DISABLE;
 8008206:	4b04      	ldr	r3, [pc, #16]	@ (8008218 <USART2_Init+0x3c>)
 8008208:	2202      	movs	r2, #2
 800820a:	739a      	strb	r2, [r3, #14]
    USART_INIT(&usart_handle);
 800820c:	4802      	ldr	r0, [pc, #8]	@ (8008218 <USART2_Init+0x3c>)
 800820e:	f000 fc51 	bl	8008ab4 <USART_INIT>
}
 8008212:	bf00      	nop
 8008214:	bd80      	pop	{r7, pc}
 8008216:	bf00      	nop
 8008218:	20000044 	.word	0x20000044
 800821c:	40004400 	.word	0x40004400

08008220 <GPIO_ButtonInit>:
    usart_gpios.GPIO_Config_t.GPIO_PinNumber = GPIO_PIN_NO_3;
    GPIO_INIT(&usart_gpios);
}

void GPIO_ButtonInit(void)
{
 8008220:	b580      	push	{r7, lr}
 8008222:	b086      	sub	sp, #24
 8008224:	af00      	add	r7, sp, #0
	GPIO_Handle_t GPIOBtn,GpioLed;

	//this is btn gpio configurationp
	GPIOBtn.pGPIOx = GPIOC;
 8008226:	4b12      	ldr	r3, [pc, #72]	@ (8008270 <GPIO_ButtonInit+0x50>)
 8008228:	60fb      	str	r3, [r7, #12]
	GPIOBtn.GPIO_Config_t.GPIO_PinNumber = GPIO_PIN_NO_13;
 800822a:	230d      	movs	r3, #13
 800822c:	743b      	strb	r3, [r7, #16]
	GPIOBtn.GPIO_Config_t.GPIO_PinMode = GPIO_MODE_INPUT;
 800822e:	2300      	movs	r3, #0
 8008230:	747b      	strb	r3, [r7, #17]
	GPIOBtn.GPIO_Config_t.GPIO_PinSpeed = GPIO_SPEED_HIGH_SPEED;
 8008232:	2302      	movs	r3, #2
 8008234:	74bb      	strb	r3, [r7, #18]
	GPIOBtn.GPIO_Config_t.GPIO_PinPuPdControl = GPIO_PUPD_NO;
 8008236:	2300      	movs	r3, #0
 8008238:	74fb      	strb	r3, [r7, #19]

	GPIO_INIT(&GPIOBtn);
 800823a:	f107 030c 	add.w	r3, r7, #12
 800823e:	4618      	mov	r0, r3
 8008240:	f000 fa0e 	bl	8008660 <GPIO_INIT>

	//this is led gpio configuration
	GpioLed.pGPIOx = GPIOA;
 8008244:	f04f 4390 	mov.w	r3, #1207959552	@ 0x48000000
 8008248:	603b      	str	r3, [r7, #0]
	GpioLed.GPIO_Config_t.GPIO_PinNumber = GPIO_PIN_NO_5;
 800824a:	2305      	movs	r3, #5
 800824c:	713b      	strb	r3, [r7, #4]
	GpioLed.GPIO_Config_t.GPIO_PinMode = GPIO_MODE_OUTPUT;
 800824e:	2301      	movs	r3, #1
 8008250:	717b      	strb	r3, [r7, #5]
	GpioLed.GPIO_Config_t.GPIO_PinSpeed = GPIO_SPEED_HIGH_SPEED;
 8008252:	2302      	movs	r3, #2
 8008254:	71bb      	strb	r3, [r7, #6]
	GpioLed.GPIO_Config_t.GPIO_PinOPType = GPIO_TYPE_PUSH_PULL;
 8008256:	2300      	movs	r3, #0
 8008258:	723b      	strb	r3, [r7, #8]
	GpioLed.GPIO_Config_t.GPIO_PinPuPdControl = GPIO_PUPD_NO;
 800825a:	2300      	movs	r3, #0
 800825c:	71fb      	strb	r3, [r7, #7]

	GPIO_INIT(&GpioLed);
 800825e:	463b      	mov	r3, r7
 8008260:	4618      	mov	r0, r3
 8008262:	f000 f9fd 	bl	8008660 <GPIO_INIT>

}
 8008266:	bf00      	nop
 8008268:	3718      	adds	r7, #24
 800826a:	46bd      	mov	sp, r7
 800826c:	bd80      	pop	{r7, pc}
 800826e:	bf00      	nop
 8008270:	48000800 	.word	0x48000800

08008274 <delays>:



void delays(void)
{
 8008274:	b480      	push	{r7}
 8008276:	b083      	sub	sp, #12
 8008278:	af00      	add	r7, sp, #0
	for(uint32_t i = 0 ; i < 500000/2 ; i ++);
 800827a:	2300      	movs	r3, #0
 800827c:	607b      	str	r3, [r7, #4]
 800827e:	e002      	b.n	8008286 <delays+0x12>
 8008280:	687b      	ldr	r3, [r7, #4]
 8008282:	3301      	adds	r3, #1
 8008284:	607b      	str	r3, [r7, #4]
 8008286:	687b      	ldr	r3, [r7, #4]
 8008288:	4a04      	ldr	r2, [pc, #16]	@ (800829c <delays+0x28>)
 800828a:	4293      	cmp	r3, r2
 800828c:	d9f8      	bls.n	8008280 <delays+0xc>
}
 800828e:	bf00      	nop
 8008290:	bf00      	nop
 8008292:	370c      	adds	r7, #12
 8008294:	46bd      	mov	sp, r7
 8008296:	bc80      	pop	{r7}
 8008298:	4770      	bx	lr
 800829a:	bf00      	nop
 800829c:	0003d08f 	.word	0x0003d08f

080082a0 <main>:




int main(void)
{
 80082a0:	b580      	push	{r7, lr}
 80082a2:	af00      	add	r7, sp, #0
    GPIO_ButtonInit(); // optional, for bootloader button
 80082a4:	f7ff ffbc 	bl	8008220 <GPIO_ButtonInit>
//   USART2_GPIOInit();
   USART2_Init();
 80082a8:	f7ff ff98 	bl	80081dc <USART2_Init>
 // USART_IRQInterruptConfig(IRQ_NO_USART2,ENABLE);
   USART_PeripheralControl(USART2, ENABLE);
 80082ac:	2101      	movs	r1, #1
 80082ae:	480b      	ldr	r0, [pc, #44]	@ (80082dc <main+0x3c>)
 80082b0:	f000 fd5d 	bl	8008d6e <USART_PeripheralControl>



while (1)
{
	 USART_SEND_DATA(&usart_handle, (uint8_t*)msg, strlen(msg));
 80082b4:	480a      	ldr	r0, [pc, #40]	@ (80082e0 <main+0x40>)
 80082b6:	f7ff ff89 	bl	80081cc <strlen>
 80082ba:	4603      	mov	r3, r0
 80082bc:	b2db      	uxtb	r3, r3
 80082be:	461a      	mov	r2, r3
 80082c0:	4907      	ldr	r1, [pc, #28]	@ (80082e0 <main+0x40>)
 80082c2:	4808      	ldr	r0, [pc, #32]	@ (80082e4 <main+0x44>)
 80082c4:	f000 fd04 	bl	8008cd0 <USART_SEND_DATA>
   delays();
 80082c8:	f7ff ffd4 	bl	8008274 <delays>
   GPIO_WRITE_TO_INPUT_PIN(GPIOA, GPIO_PIN_NO_5, GPIO_PIN_SET);
 80082cc:	2201      	movs	r2, #1
 80082ce:	2105      	movs	r1, #5
 80082d0:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 80082d4:	f000 fbca 	bl	8008a6c <GPIO_WRITE_TO_INPUT_PIN>
	 USART_SEND_DATA(&usart_handle, (uint8_t*)msg, strlen(msg));
 80082d8:	bf00      	nop
 80082da:	e7eb      	b.n	80082b4 <main+0x14>
 80082dc:	40004400 	.word	0x40004400
 80082e0:	20000000 	.word	0x20000000
 80082e4:	20000044 	.word	0x20000044

080082e8 <USART2_IRQHandler>:
 }



void USART2_IRQHandler(void)
{
 80082e8:	b580      	push	{r7, lr}
 80082ea:	af00      	add	r7, sp, #0
    USART_IRQHandling(&usart_handle);
 80082ec:	4802      	ldr	r0, [pc, #8]	@ (80082f8 <USART2_IRQHandler+0x10>)
 80082ee:	f000 fdab 	bl	8008e48 <USART_IRQHandling>
}
 80082f2:	bf00      	nop
 80082f4:	bd80      	pop	{r7, pc}
 80082f6:	bf00      	nop
 80082f8:	20000044 	.word	0x20000044

080082fc <SystemInit>:

void SystemInit(void)
{
 80082fc:	b480      	push	{r7}
 80082fe:	af00      	add	r7, sp, #0

    SCB->VTOR = 0x08008000;
 8008300:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8008304:	4a02      	ldr	r2, [pc, #8]	@ (8008310 <SystemInit+0x14>)
 8008306:	609a      	str	r2, [r3, #8]
}
 8008308:	bf00      	nop
 800830a:	46bd      	mov	sp, r7
 800830c:	bc80      	pop	{r7}
 800830e:	4770      	bx	lr
 8008310:	08008000 	.word	0x08008000

08008314 <Reset_Handler>:

  .section .text.Reset_Handler
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 8008314:	480d      	ldr	r0, [pc, #52]	@ (800834c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 8008316:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
 8008318:	f7ff fff0 	bl	80082fc <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 800831c:	480c      	ldr	r0, [pc, #48]	@ (8008350 <LoopForever+0x6>)
  ldr r1, =_edata
 800831e:	490d      	ldr	r1, [pc, #52]	@ (8008354 <LoopForever+0xa>)
  ldr r2, =_sidata
 8008320:	4a0d      	ldr	r2, [pc, #52]	@ (8008358 <LoopForever+0xe>)
  movs r3, #0
 8008322:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8008324:	e002      	b.n	800832c <LoopCopyDataInit>

08008326 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8008326:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8008328:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 800832a:	3304      	adds	r3, #4

0800832c <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 800832c:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 800832e:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8008330:	d3f9      	bcc.n	8008326 <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8008332:	4a0a      	ldr	r2, [pc, #40]	@ (800835c <LoopForever+0x12>)
  ldr r4, =_ebss
 8008334:	4c0a      	ldr	r4, [pc, #40]	@ (8008360 <LoopForever+0x16>)
  movs r3, #0
 8008336:	2300      	movs	r3, #0
  b LoopFillZerobss
 8008338:	e001      	b.n	800833e <LoopFillZerobss>

0800833a <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 800833a:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 800833c:	3204      	adds	r2, #4

0800833e <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800833e:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8008340:	d3fb      	bcc.n	800833a <FillZerobss>


/* Call static constructors */
  bl __libc_init_array
 8008342:	f000 ff5f 	bl	8009204 <__libc_init_array>
/* Call the application's entry point.*/

  bl main
 8008346:	f7ff ffab 	bl	80082a0 <main>

0800834a <LoopForever>:

LoopForever:
  b LoopForever
 800834a:	e7fe      	b.n	800834a <LoopForever>
  ldr   r0, =_estack
 800834c:	20018000 	.word	0x20018000
  ldr r0, =_sdata
 8008350:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8008354:	20000028 	.word	0x20000028
  ldr r2, =_sidata
 8008358:	08009274 	.word	0x08009274
  ldr r2, =_sbss
 800835c:	20000028 	.word	0x20000028
  ldr r4, =_ebss
 8008360:	20000060 	.word	0x20000060

08008364 <ADC1_2_IRQHandler>:
 * @retval : None
*/
  .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8008364:	e7fe      	b.n	8008364 <ADC1_2_IRQHandler>
	...

08008368 <RCC_GetMSIClock>:

#define HSE_VALUE 8000000U


static uint32_t RCC_GetMSIClock(void)
{
 8008368:	b480      	push	{r7}
 800836a:	b083      	sub	sp, #12
 800836c:	af00      	add	r7, sp, #0

    uint32_t msirange = (RCC->CR >> 4) & 0xF;
 800836e:	4b21      	ldr	r3, [pc, #132]	@ (80083f4 <RCC_GetMSIClock+0x8c>)
 8008370:	681b      	ldr	r3, [r3, #0]
 8008372:	091b      	lsrs	r3, r3, #4
 8008374:	f003 030f 	and.w	r3, r3, #15
 8008378:	607b      	str	r3, [r7, #4]

    switch(msirange)
 800837a:	687b      	ldr	r3, [r7, #4]
 800837c:	2b0b      	cmp	r3, #11
 800837e:	d833      	bhi.n	80083e8 <RCC_GetMSIClock+0x80>
 8008380:	a201      	add	r2, pc, #4	@ (adr r2, 8008388 <RCC_GetMSIClock+0x20>)
 8008382:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8008386:	bf00      	nop
 8008388:	080083b9 	.word	0x080083b9
 800838c:	080083bd 	.word	0x080083bd
 8008390:	080083c1 	.word	0x080083c1
 8008394:	080083c5 	.word	0x080083c5
 8008398:	080083c9 	.word	0x080083c9
 800839c:	080083cd 	.word	0x080083cd
 80083a0:	080083d1 	.word	0x080083d1
 80083a4:	080083d5 	.word	0x080083d5
 80083a8:	080083d9 	.word	0x080083d9
 80083ac:	080083dd 	.word	0x080083dd
 80083b0:	080083e1 	.word	0x080083e1
 80083b4:	080083e5 	.word	0x080083e5
    {
        case 0:  return 100000;   // 100 kHz
 80083b8:	4b0f      	ldr	r3, [pc, #60]	@ (80083f8 <RCC_GetMSIClock+0x90>)
 80083ba:	e016      	b.n	80083ea <RCC_GetMSIClock+0x82>
        case 1:  return 200000;   // 200 kHz
 80083bc:	4b0f      	ldr	r3, [pc, #60]	@ (80083fc <RCC_GetMSIClock+0x94>)
 80083be:	e014      	b.n	80083ea <RCC_GetMSIClock+0x82>
        case 2:  return 400000;   // 400 kHz
 80083c0:	4b0f      	ldr	r3, [pc, #60]	@ (8008400 <RCC_GetMSIClock+0x98>)
 80083c2:	e012      	b.n	80083ea <RCC_GetMSIClock+0x82>
        case 3:  return 800000;   // 800 kHz
 80083c4:	4b0f      	ldr	r3, [pc, #60]	@ (8008404 <RCC_GetMSIClock+0x9c>)
 80083c6:	e010      	b.n	80083ea <RCC_GetMSIClock+0x82>
        case 4:  return 1000000;  // 1 MHz
 80083c8:	4b0f      	ldr	r3, [pc, #60]	@ (8008408 <RCC_GetMSIClock+0xa0>)
 80083ca:	e00e      	b.n	80083ea <RCC_GetMSIClock+0x82>
        case 5:  return 2000000;  // 2 MHz
 80083cc:	4b0f      	ldr	r3, [pc, #60]	@ (800840c <RCC_GetMSIClock+0xa4>)
 80083ce:	e00c      	b.n	80083ea <RCC_GetMSIClock+0x82>
        case 6:  return 4000000;  // 4 MHz
 80083d0:	4b0f      	ldr	r3, [pc, #60]	@ (8008410 <RCC_GetMSIClock+0xa8>)
 80083d2:	e00a      	b.n	80083ea <RCC_GetMSIClock+0x82>
        case 7:  return 8000000;  // 8 MHz
 80083d4:	4b0f      	ldr	r3, [pc, #60]	@ (8008414 <RCC_GetMSIClock+0xac>)
 80083d6:	e008      	b.n	80083ea <RCC_GetMSIClock+0x82>
        case 8:  return 16000000; // 16 MHz
 80083d8:	4b0f      	ldr	r3, [pc, #60]	@ (8008418 <RCC_GetMSIClock+0xb0>)
 80083da:	e006      	b.n	80083ea <RCC_GetMSIClock+0x82>
        case 9:  return 24000000; // 24 MHz
 80083dc:	4b0f      	ldr	r3, [pc, #60]	@ (800841c <RCC_GetMSIClock+0xb4>)
 80083de:	e004      	b.n	80083ea <RCC_GetMSIClock+0x82>
        case 10: return 32000000; // 32 MHz
 80083e0:	4b0f      	ldr	r3, [pc, #60]	@ (8008420 <RCC_GetMSIClock+0xb8>)
 80083e2:	e002      	b.n	80083ea <RCC_GetMSIClock+0x82>
        case 11: return 48000000; // 48 MHz
 80083e4:	4b0f      	ldr	r3, [pc, #60]	@ (8008424 <RCC_GetMSIClock+0xbc>)
 80083e6:	e000      	b.n	80083ea <RCC_GetMSIClock+0x82>
        default: return 4000000;  // default safe fallback
 80083e8:	4b09      	ldr	r3, [pc, #36]	@ (8008410 <RCC_GetMSIClock+0xa8>)
    }
}
 80083ea:	4618      	mov	r0, r3
 80083ec:	370c      	adds	r7, #12
 80083ee:	46bd      	mov	sp, r7
 80083f0:	bc80      	pop	{r7}
 80083f2:	4770      	bx	lr
 80083f4:	40021000 	.word	0x40021000
 80083f8:	000186a0 	.word	0x000186a0
 80083fc:	00030d40 	.word	0x00030d40
 8008400:	00061a80 	.word	0x00061a80
 8008404:	000c3500 	.word	0x000c3500
 8008408:	000f4240 	.word	0x000f4240
 800840c:	001e8480 	.word	0x001e8480
 8008410:	003d0900 	.word	0x003d0900
 8008414:	007a1200 	.word	0x007a1200
 8008418:	00f42400 	.word	0x00f42400
 800841c:	016e3600 	.word	0x016e3600
 8008420:	01e84800 	.word	0x01e84800
 8008424:	02dc6c00 	.word	0x02dc6c00

08008428 <RCC_GetPLLOutputClock>:

 uint32_t RCC_GetPLLOutputClock(void)
{
 8008428:	b580      	push	{r7, lr}
 800842a:	b086      	sub	sp, #24
 800842c:	af00      	add	r7, sp, #0
    uint32_t pll_src, pll_m, pll_n, pll_r;
    uint32_t pll_input, pll_vco;

    pll_src = (RCC->PLLCFGR >> 0) & 0x3;   // PLLSRC bits [1:0]
 800842e:	4b21      	ldr	r3, [pc, #132]	@ (80084b4 <RCC_GetPLLOutputClock+0x8c>)
 8008430:	68db      	ldr	r3, [r3, #12]
 8008432:	f003 0303 	and.w	r3, r3, #3
 8008436:	613b      	str	r3, [r7, #16]
    pll_m   = ((RCC->PLLCFGR >> 4) & 0x7) + 1;  // PLLM (รท1..รท8)
 8008438:	4b1e      	ldr	r3, [pc, #120]	@ (80084b4 <RCC_GetPLLOutputClock+0x8c>)
 800843a:	68db      	ldr	r3, [r3, #12]
 800843c:	091b      	lsrs	r3, r3, #4
 800843e:	f003 0307 	and.w	r3, r3, #7
 8008442:	3301      	adds	r3, #1
 8008444:	60fb      	str	r3, [r7, #12]
    pll_n   = (RCC->PLLCFGR >> 8) & 0x7F;       // PLLN (8..86)
 8008446:	4b1b      	ldr	r3, [pc, #108]	@ (80084b4 <RCC_GetPLLOutputClock+0x8c>)
 8008448:	68db      	ldr	r3, [r3, #12]
 800844a:	0a1b      	lsrs	r3, r3, #8
 800844c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
 8008450:	60bb      	str	r3, [r7, #8]
    pll_r   = (((RCC->PLLCFGR >> 25) & 0x3) + 1) * 2; // PLLR (รท2,4,6,8)
 8008452:	4b18      	ldr	r3, [pc, #96]	@ (80084b4 <RCC_GetPLLOutputClock+0x8c>)
 8008454:	68db      	ldr	r3, [r3, #12]
 8008456:	0e5b      	lsrs	r3, r3, #25
 8008458:	f003 0303 	and.w	r3, r3, #3
 800845c:	3301      	adds	r3, #1
 800845e:	005b      	lsls	r3, r3, #1
 8008460:	607b      	str	r3, [r7, #4]

    // PLL input clock
    switch(pll_src)
 8008462:	693b      	ldr	r3, [r7, #16]
 8008464:	2b03      	cmp	r3, #3
 8008466:	d00f      	beq.n	8008488 <RCC_GetPLLOutputClock+0x60>
 8008468:	693b      	ldr	r3, [r7, #16]
 800846a:	2b03      	cmp	r3, #3
 800846c:	d810      	bhi.n	8008490 <RCC_GetPLLOutputClock+0x68>
 800846e:	693b      	ldr	r3, [r7, #16]
 8008470:	2b01      	cmp	r3, #1
 8008472:	d003      	beq.n	800847c <RCC_GetPLLOutputClock+0x54>
 8008474:	693b      	ldr	r3, [r7, #16]
 8008476:	2b02      	cmp	r3, #2
 8008478:	d003      	beq.n	8008482 <RCC_GetPLLOutputClock+0x5a>
 800847a:	e009      	b.n	8008490 <RCC_GetPLLOutputClock+0x68>
    {
        case 1: pll_input = 16000000; break;         // HSI16
 800847c:	4b0e      	ldr	r3, [pc, #56]	@ (80084b8 <RCC_GetPLLOutputClock+0x90>)
 800847e:	617b      	str	r3, [r7, #20]
 8008480:	e008      	b.n	8008494 <RCC_GetPLLOutputClock+0x6c>
        case 2: pll_input = HSE_VALUE; break;        // HSE
 8008482:	4b0e      	ldr	r3, [pc, #56]	@ (80084bc <RCC_GetPLLOutputClock+0x94>)
 8008484:	617b      	str	r3, [r7, #20]
 8008486:	e005      	b.n	8008494 <RCC_GetPLLOutputClock+0x6c>
        case 3: pll_input = RCC_GetMSIClock(); break; // MSI
 8008488:	f7ff ff6e 	bl	8008368 <RCC_GetMSIClock>
 800848c:	6178      	str	r0, [r7, #20]
 800848e:	e001      	b.n	8008494 <RCC_GetPLLOutputClock+0x6c>
        default: return 0; // No source
 8008490:	2300      	movs	r3, #0
 8008492:	e00b      	b.n	80084ac <RCC_GetPLLOutputClock+0x84>
    }

    pll_vco = (pll_input / pll_m) * pll_n;   // VCO frequency
 8008494:	697a      	ldr	r2, [r7, #20]
 8008496:	68fb      	ldr	r3, [r7, #12]
 8008498:	fbb2 f2f3 	udiv	r2, r2, r3
 800849c:	68bb      	ldr	r3, [r7, #8]
 800849e:	fb02 f303 	mul.w	r3, r2, r3
 80084a2:	603b      	str	r3, [r7, #0]
    return pll_vco / pll_r;                  // PLLR output
 80084a4:	683a      	ldr	r2, [r7, #0]
 80084a6:	687b      	ldr	r3, [r7, #4]
 80084a8:	fbb2 f3f3 	udiv	r3, r2, r3
}
 80084ac:	4618      	mov	r0, r3
 80084ae:	3718      	adds	r7, #24
 80084b0:	46bd      	mov	sp, r7
 80084b2:	bd80      	pop	{r7, pc}
 80084b4:	40021000 	.word	0x40021000
 80084b8:	00f42400 	.word	0x00f42400
 80084bc:	007a1200 	.word	0x007a1200

080084c0 <RCC_GetPCLK1Value>:


uint32_t RCC_GetPCLK1Value(void)
{
 80084c0:	b580      	push	{r7, lr}
 80084c2:	b084      	sub	sp, #16
 80084c4:	af00      	add	r7, sp, #0
    uint32_t SystemClock, pclk1;
    uint8_t ahbp, apb1p;

    uint8_t clk_src = (RCC->CFGR >> 2) & 0x3; // SWS bits
 80084c6:	4b2c      	ldr	r3, [pc, #176]	@ (8008578 <RCC_GetPCLK1Value+0xb8>)
 80084c8:	689b      	ldr	r3, [r3, #8]
 80084ca:	089b      	lsrs	r3, r3, #2
 80084cc:	b2db      	uxtb	r3, r3
 80084ce:	f003 0303 	and.w	r3, r3, #3
 80084d2:	727b      	strb	r3, [r7, #9]

    switch(clk_src)
 80084d4:	7a7b      	ldrb	r3, [r7, #9]
 80084d6:	2b03      	cmp	r3, #3
 80084d8:	d818      	bhi.n	800850c <RCC_GetPCLK1Value+0x4c>
 80084da:	a201      	add	r2, pc, #4	@ (adr r2, 80084e0 <RCC_GetPCLK1Value+0x20>)
 80084dc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80084e0:	080084f1 	.word	0x080084f1
 80084e4:	080084f9 	.word	0x080084f9
 80084e8:	080084ff 	.word	0x080084ff
 80084ec:	08008505 	.word	0x08008505
    {
        case 0: SystemClock = RCC_GetMSIClock(); break;
 80084f0:	f7ff ff3a 	bl	8008368 <RCC_GetMSIClock>
 80084f4:	60f8      	str	r0, [r7, #12]
 80084f6:	e00c      	b.n	8008512 <RCC_GetPCLK1Value+0x52>
        case 1: SystemClock = 16000000; break; // HSI16
 80084f8:	4b20      	ldr	r3, [pc, #128]	@ (800857c <RCC_GetPCLK1Value+0xbc>)
 80084fa:	60fb      	str	r3, [r7, #12]
 80084fc:	e009      	b.n	8008512 <RCC_GetPCLK1Value+0x52>
        case 2: SystemClock = HSE_VALUE; break;
 80084fe:	4b20      	ldr	r3, [pc, #128]	@ (8008580 <RCC_GetPCLK1Value+0xc0>)
 8008500:	60fb      	str	r3, [r7, #12]
 8008502:	e006      	b.n	8008512 <RCC_GetPCLK1Value+0x52>
        case 3: SystemClock = RCC_GetPLLOutputClock(); break;
 8008504:	f7ff ff90 	bl	8008428 <RCC_GetPLLOutputClock>
 8008508:	60f8      	str	r0, [r7, #12]
 800850a:	e002      	b.n	8008512 <RCC_GetPCLK1Value+0x52>
        default: SystemClock = 4000000; break;
 800850c:	4b1d      	ldr	r3, [pc, #116]	@ (8008584 <RCC_GetPCLK1Value+0xc4>)
 800850e:	60fb      	str	r3, [r7, #12]
 8008510:	bf00      	nop
    }

    // AHB prescaler
    uint8_t tmp = (RCC->CFGR >> 4) & 0xF;
 8008512:	4b19      	ldr	r3, [pc, #100]	@ (8008578 <RCC_GetPCLK1Value+0xb8>)
 8008514:	689b      	ldr	r3, [r3, #8]
 8008516:	091b      	lsrs	r3, r3, #4
 8008518:	b2db      	uxtb	r3, r3
 800851a:	f003 030f 	and.w	r3, r3, #15
 800851e:	723b      	strb	r3, [r7, #8]
    if(tmp < 8) ahbp = 1;
 8008520:	7a3b      	ldrb	r3, [r7, #8]
 8008522:	2b07      	cmp	r3, #7
 8008524:	d802      	bhi.n	800852c <RCC_GetPCLK1Value+0x6c>
 8008526:	2301      	movs	r3, #1
 8008528:	72fb      	strb	r3, [r7, #11]
 800852a:	e005      	b.n	8008538 <RCC_GetPCLK1Value+0x78>
    else ahbp = AHB_PreScaler[tmp-8];
 800852c:	7a3b      	ldrb	r3, [r7, #8]
 800852e:	3b08      	subs	r3, #8
 8008530:	4a15      	ldr	r2, [pc, #84]	@ (8008588 <RCC_GetPCLK1Value+0xc8>)
 8008532:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8008536:	72fb      	strb	r3, [r7, #11]

    // APB1 prescaler
    tmp = (RCC->CFGR >> 10) & 0x7;
 8008538:	4b0f      	ldr	r3, [pc, #60]	@ (8008578 <RCC_GetPCLK1Value+0xb8>)
 800853a:	689b      	ldr	r3, [r3, #8]
 800853c:	0a9b      	lsrs	r3, r3, #10
 800853e:	b2db      	uxtb	r3, r3
 8008540:	f003 0307 	and.w	r3, r3, #7
 8008544:	723b      	strb	r3, [r7, #8]
    if(tmp < 4) apb1p = 1;
 8008546:	7a3b      	ldrb	r3, [r7, #8]
 8008548:	2b03      	cmp	r3, #3
 800854a:	d802      	bhi.n	8008552 <RCC_GetPCLK1Value+0x92>
 800854c:	2301      	movs	r3, #1
 800854e:	72bb      	strb	r3, [r7, #10]
 8008550:	e004      	b.n	800855c <RCC_GetPCLK1Value+0x9c>
    else apb1p = APB_PreScaler[tmp-4];
 8008552:	7a3b      	ldrb	r3, [r7, #8]
 8008554:	3b04      	subs	r3, #4
 8008556:	4a0d      	ldr	r2, [pc, #52]	@ (800858c <RCC_GetPCLK1Value+0xcc>)
 8008558:	5cd3      	ldrb	r3, [r2, r3]
 800855a:	72bb      	strb	r3, [r7, #10]

    pclk1 = (SystemClock / ahbp) / apb1p;
 800855c:	7afb      	ldrb	r3, [r7, #11]
 800855e:	68fa      	ldr	r2, [r7, #12]
 8008560:	fbb2 f2f3 	udiv	r2, r2, r3
 8008564:	7abb      	ldrb	r3, [r7, #10]
 8008566:	fbb2 f3f3 	udiv	r3, r2, r3
 800856a:	607b      	str	r3, [r7, #4]
    return pclk1;
 800856c:	687b      	ldr	r3, [r7, #4]
}
 800856e:	4618      	mov	r0, r3
 8008570:	3710      	adds	r7, #16
 8008572:	46bd      	mov	sp, r7
 8008574:	bd80      	pop	{r7, pc}
 8008576:	bf00      	nop
 8008578:	40021000 	.word	0x40021000
 800857c:	00f42400 	.word	0x00f42400
 8008580:	007a1200 	.word	0x007a1200
 8008584:	003d0900 	.word	0x003d0900
 8008588:	20000014 	.word	0x20000014
 800858c:	20000024 	.word	0x20000024

08008590 <RCC_GetPCLK2Value>:


uint32_t RCC_GetPCLK2Value(void)
{
 8008590:	b580      	push	{r7, lr}
 8008592:	b084      	sub	sp, #16
 8008594:	af00      	add	r7, sp, #0
    uint32_t SystemClock, pclk2;
    uint8_t ahbp, apb2p;

    uint8_t clk_src = (RCC->CFGR >> 2) & 0x3;
 8008596:	4b2c      	ldr	r3, [pc, #176]	@ (8008648 <RCC_GetPCLK2Value+0xb8>)
 8008598:	689b      	ldr	r3, [r3, #8]
 800859a:	089b      	lsrs	r3, r3, #2
 800859c:	b2db      	uxtb	r3, r3
 800859e:	f003 0303 	and.w	r3, r3, #3
 80085a2:	727b      	strb	r3, [r7, #9]

    switch(clk_src)
 80085a4:	7a7b      	ldrb	r3, [r7, #9]
 80085a6:	2b03      	cmp	r3, #3
 80085a8:	d818      	bhi.n	80085dc <RCC_GetPCLK2Value+0x4c>
 80085aa:	a201      	add	r2, pc, #4	@ (adr r2, 80085b0 <RCC_GetPCLK2Value+0x20>)
 80085ac:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80085b0:	080085c1 	.word	0x080085c1
 80085b4:	080085c9 	.word	0x080085c9
 80085b8:	080085cf 	.word	0x080085cf
 80085bc:	080085d5 	.word	0x080085d5
    {
        case 0: SystemClock = RCC_GetMSIClock(); break;
 80085c0:	f7ff fed2 	bl	8008368 <RCC_GetMSIClock>
 80085c4:	60f8      	str	r0, [r7, #12]
 80085c6:	e00c      	b.n	80085e2 <RCC_GetPCLK2Value+0x52>
        case 1: SystemClock = 16000000; break;
 80085c8:	4b20      	ldr	r3, [pc, #128]	@ (800864c <RCC_GetPCLK2Value+0xbc>)
 80085ca:	60fb      	str	r3, [r7, #12]
 80085cc:	e009      	b.n	80085e2 <RCC_GetPCLK2Value+0x52>
        case 2: SystemClock = HSE_VALUE; break;
 80085ce:	4b20      	ldr	r3, [pc, #128]	@ (8008650 <RCC_GetPCLK2Value+0xc0>)
 80085d0:	60fb      	str	r3, [r7, #12]
 80085d2:	e006      	b.n	80085e2 <RCC_GetPCLK2Value+0x52>
        case 3: SystemClock = RCC_GetPLLOutputClock(); break;
 80085d4:	f7ff ff28 	bl	8008428 <RCC_GetPLLOutputClock>
 80085d8:	60f8      	str	r0, [r7, #12]
 80085da:	e002      	b.n	80085e2 <RCC_GetPCLK2Value+0x52>
        default: SystemClock = 4000000; break;
 80085dc:	4b1d      	ldr	r3, [pc, #116]	@ (8008654 <RCC_GetPCLK2Value+0xc4>)
 80085de:	60fb      	str	r3, [r7, #12]
 80085e0:	bf00      	nop
    }

    // AHB prescaler
    uint8_t tmp = (RCC->CFGR >> 4) & 0xF;
 80085e2:	4b19      	ldr	r3, [pc, #100]	@ (8008648 <RCC_GetPCLK2Value+0xb8>)
 80085e4:	689b      	ldr	r3, [r3, #8]
 80085e6:	091b      	lsrs	r3, r3, #4
 80085e8:	b2db      	uxtb	r3, r3
 80085ea:	f003 030f 	and.w	r3, r3, #15
 80085ee:	723b      	strb	r3, [r7, #8]
    if(tmp < 8) ahbp = 1;
 80085f0:	7a3b      	ldrb	r3, [r7, #8]
 80085f2:	2b07      	cmp	r3, #7
 80085f4:	d802      	bhi.n	80085fc <RCC_GetPCLK2Value+0x6c>
 80085f6:	2301      	movs	r3, #1
 80085f8:	72fb      	strb	r3, [r7, #11]
 80085fa:	e005      	b.n	8008608 <RCC_GetPCLK2Value+0x78>
    else ahbp = AHB_PreScaler[tmp-8];
 80085fc:	7a3b      	ldrb	r3, [r7, #8]
 80085fe:	3b08      	subs	r3, #8
 8008600:	4a15      	ldr	r2, [pc, #84]	@ (8008658 <RCC_GetPCLK2Value+0xc8>)
 8008602:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
 8008606:	72fb      	strb	r3, [r7, #11]

    // APB2 prescaler
    tmp = (RCC->CFGR >> 11) & 0x7;
 8008608:	4b0f      	ldr	r3, [pc, #60]	@ (8008648 <RCC_GetPCLK2Value+0xb8>)
 800860a:	689b      	ldr	r3, [r3, #8]
 800860c:	0adb      	lsrs	r3, r3, #11
 800860e:	b2db      	uxtb	r3, r3
 8008610:	f003 0307 	and.w	r3, r3, #7
 8008614:	723b      	strb	r3, [r7, #8]
    if(tmp < 4) apb2p = 1;
 8008616:	7a3b      	ldrb	r3, [r7, #8]
 8008618:	2b03      	cmp	r3, #3
 800861a:	d802      	bhi.n	8008622 <RCC_GetPCLK2Value+0x92>
 800861c:	2301      	movs	r3, #1
 800861e:	72bb      	strb	r3, [r7, #10]
 8008620:	e004      	b.n	800862c <RCC_GetPCLK2Value+0x9c>
    else apb2p = APB_PreScaler[tmp-4];
 8008622:	7a3b      	ldrb	r3, [r7, #8]
 8008624:	3b04      	subs	r3, #4
 8008626:	4a0d      	ldr	r2, [pc, #52]	@ (800865c <RCC_GetPCLK2Value+0xcc>)
 8008628:	5cd3      	ldrb	r3, [r2, r3]
 800862a:	72bb      	strb	r3, [r7, #10]

    pclk2 = (SystemClock / ahbp) / apb2p;
 800862c:	7afb      	ldrb	r3, [r7, #11]
 800862e:	68fa      	ldr	r2, [r7, #12]
 8008630:	fbb2 f2f3 	udiv	r2, r2, r3
 8008634:	7abb      	ldrb	r3, [r7, #10]
 8008636:	fbb2 f3f3 	udiv	r3, r2, r3
 800863a:	607b      	str	r3, [r7, #4]
    return pclk2;
 800863c:	687b      	ldr	r3, [r7, #4]
}
 800863e:	4618      	mov	r0, r3
 8008640:	3710      	adds	r7, #16
 8008642:	46bd      	mov	sp, r7
 8008644:	bd80      	pop	{r7, pc}
 8008646:	bf00      	nop
 8008648:	40021000 	.word	0x40021000
 800864c:	00f42400 	.word	0x00f42400
 8008650:	007a1200 	.word	0x007a1200
 8008654:	003d0900 	.word	0x003d0900
 8008658:	20000014 	.word	0x20000014
 800865c:	20000024 	.word	0x20000024

08008660 <GPIO_INIT>:



//init and deinit apii
void GPIO_INIT(GPIO_Handle_t *pGPIOhandle)
{   //clk enable for the gpio
 8008660:	b580      	push	{r7, lr}
 8008662:	b084      	sub	sp, #16
 8008664:	af00      	add	r7, sp, #0
 8008666:	6078      	str	r0, [r7, #4]
	GPIO_PERI_CTRL(pGPIOhandle->pGPIOx, ENABLE);
 8008668:	687b      	ldr	r3, [r7, #4]
 800866a:	681b      	ldr	r3, [r3, #0]
 800866c:	2101      	movs	r1, #1
 800866e:	4618      	mov	r0, r3
 8008670:	f000 f916 	bl	80088a0 <GPIO_PERI_CTRL>

uint32_t tempreg;

if(pGPIOhandle->GPIO_Config_t.GPIO_PinMode <= GPIO_MODE_ANALOG )
 8008674:	687b      	ldr	r3, [r7, #4]
 8008676:	795b      	ldrb	r3, [r3, #5]
 8008678:	2b03      	cmp	r3, #3
 800867a:	d820      	bhi.n	80086be <GPIO_INIT+0x5e>
{
	//non interrupt mode
	tempreg = (pGPIOhandle->GPIO_Config_t.GPIO_PinMode <<  (2 * pGPIOhandle->GPIO_Config_t.GPIO_PinNumber));
 800867c:	687b      	ldr	r3, [r7, #4]
 800867e:	795b      	ldrb	r3, [r3, #5]
 8008680:	461a      	mov	r2, r3
 8008682:	687b      	ldr	r3, [r7, #4]
 8008684:	791b      	ldrb	r3, [r3, #4]
 8008686:	005b      	lsls	r3, r3, #1
 8008688:	fa02 f303 	lsl.w	r3, r2, r3
 800868c:	60fb      	str	r3, [r7, #12]
	//clear the register
	pGPIOhandle->pGPIOx->MODER &= ~( 0x3 << (2 * pGPIOhandle->GPIO_Config_t.GPIO_PinNumber));
 800868e:	687b      	ldr	r3, [r7, #4]
 8008690:	681b      	ldr	r3, [r3, #0]
 8008692:	681a      	ldr	r2, [r3, #0]
 8008694:	687b      	ldr	r3, [r7, #4]
 8008696:	791b      	ldrb	r3, [r3, #4]
 8008698:	005b      	lsls	r3, r3, #1
 800869a:	2103      	movs	r1, #3
 800869c:	fa01 f303 	lsl.w	r3, r1, r3
 80086a0:	43db      	mvns	r3, r3
 80086a2:	4619      	mov	r1, r3
 80086a4:	687b      	ldr	r3, [r7, #4]
 80086a6:	681b      	ldr	r3, [r3, #0]
 80086a8:	400a      	ands	r2, r1
 80086aa:	601a      	str	r2, [r3, #0]
	pGPIOhandle->pGPIOx->MODER |= tempreg;
 80086ac:	687b      	ldr	r3, [r7, #4]
 80086ae:	681b      	ldr	r3, [r3, #0]
 80086b0:	6819      	ldr	r1, [r3, #0]
 80086b2:	687b      	ldr	r3, [r7, #4]
 80086b4:	681b      	ldr	r3, [r3, #0]
 80086b6:	68fa      	ldr	r2, [r7, #12]
 80086b8:	430a      	orrs	r2, r1
 80086ba:	601a      	str	r2, [r3, #0]
 80086bc:	e04f      	b.n	800875e <GPIO_INIT+0xfe>
}
else
{
	//interrupt mode
	if(pGPIOhandle->GPIO_Config_t.GPIO_PinMode == GPIO_MODE_IT_FT)
 80086be:	687b      	ldr	r3, [r7, #4]
 80086c0:	795b      	ldrb	r3, [r3, #5]
 80086c2:	2b05      	cmp	r3, #5
 80086c4:	d116      	bne.n	80086f4 <GPIO_INIT+0x94>
	{
		EXTI->FTSR1 |= (1 << pGPIOhandle->GPIO_Config_t.GPIO_PinNumber)  ;
 80086c6:	4b75      	ldr	r3, [pc, #468]	@ (800889c <GPIO_INIT+0x23c>)
 80086c8:	68db      	ldr	r3, [r3, #12]
 80086ca:	687a      	ldr	r2, [r7, #4]
 80086cc:	7912      	ldrb	r2, [r2, #4]
 80086ce:	4611      	mov	r1, r2
 80086d0:	2201      	movs	r2, #1
 80086d2:	408a      	lsls	r2, r1
 80086d4:	4611      	mov	r1, r2
 80086d6:	4a71      	ldr	r2, [pc, #452]	@ (800889c <GPIO_INIT+0x23c>)
 80086d8:	430b      	orrs	r3, r1
 80086da:	60d3      	str	r3, [r2, #12]
		EXTI->RTSR1 &= ~(1 << pGPIOhandle->GPIO_Config_t.GPIO_PinNumber)  ;
 80086dc:	4b6f      	ldr	r3, [pc, #444]	@ (800889c <GPIO_INIT+0x23c>)
 80086de:	689b      	ldr	r3, [r3, #8]
 80086e0:	687a      	ldr	r2, [r7, #4]
 80086e2:	7912      	ldrb	r2, [r2, #4]
 80086e4:	4611      	mov	r1, r2
 80086e6:	2201      	movs	r2, #1
 80086e8:	408a      	lsls	r2, r1
 80086ea:	43d2      	mvns	r2, r2
 80086ec:	4611      	mov	r1, r2
 80086ee:	4a6b      	ldr	r2, [pc, #428]	@ (800889c <GPIO_INIT+0x23c>)
 80086f0:	400b      	ands	r3, r1
 80086f2:	6093      	str	r3, [r2, #8]
	}
	if(pGPIOhandle->GPIO_Config_t.GPIO_PinMode == GPIO_MODE_IT_RT)
 80086f4:	687b      	ldr	r3, [r7, #4]
 80086f6:	795b      	ldrb	r3, [r3, #5]
 80086f8:	2b04      	cmp	r3, #4
 80086fa:	d116      	bne.n	800872a <GPIO_INIT+0xca>
	{
		EXTI->FTSR1 &= ~(1 << pGPIOhandle->GPIO_Config_t.GPIO_PinNumber)  ;
 80086fc:	4b67      	ldr	r3, [pc, #412]	@ (800889c <GPIO_INIT+0x23c>)
 80086fe:	68db      	ldr	r3, [r3, #12]
 8008700:	687a      	ldr	r2, [r7, #4]
 8008702:	7912      	ldrb	r2, [r2, #4]
 8008704:	4611      	mov	r1, r2
 8008706:	2201      	movs	r2, #1
 8008708:	408a      	lsls	r2, r1
 800870a:	43d2      	mvns	r2, r2
 800870c:	4611      	mov	r1, r2
 800870e:	4a63      	ldr	r2, [pc, #396]	@ (800889c <GPIO_INIT+0x23c>)
 8008710:	400b      	ands	r3, r1
 8008712:	60d3      	str	r3, [r2, #12]
				EXTI->RTSR1 |= (1 << pGPIOhandle->GPIO_Config_t.GPIO_PinNumber)  ;
 8008714:	4b61      	ldr	r3, [pc, #388]	@ (800889c <GPIO_INIT+0x23c>)
 8008716:	689b      	ldr	r3, [r3, #8]
 8008718:	687a      	ldr	r2, [r7, #4]
 800871a:	7912      	ldrb	r2, [r2, #4]
 800871c:	4611      	mov	r1, r2
 800871e:	2201      	movs	r2, #1
 8008720:	408a      	lsls	r2, r1
 8008722:	4611      	mov	r1, r2
 8008724:	4a5d      	ldr	r2, [pc, #372]	@ (800889c <GPIO_INIT+0x23c>)
 8008726:	430b      	orrs	r3, r1
 8008728:	6093      	str	r3, [r2, #8]
	}

	if(pGPIOhandle->GPIO_Config_t.GPIO_PinMode == GPIO_MODE_IT_RFT)
 800872a:	687b      	ldr	r3, [r7, #4]
 800872c:	795b      	ldrb	r3, [r3, #5]
 800872e:	2b06      	cmp	r3, #6
 8008730:	d115      	bne.n	800875e <GPIO_INIT+0xfe>
	{

		EXTI->FTSR1 |= (1 << pGPIOhandle->GPIO_Config_t.GPIO_PinNumber)  ;
 8008732:	4b5a      	ldr	r3, [pc, #360]	@ (800889c <GPIO_INIT+0x23c>)
 8008734:	68db      	ldr	r3, [r3, #12]
 8008736:	687a      	ldr	r2, [r7, #4]
 8008738:	7912      	ldrb	r2, [r2, #4]
 800873a:	4611      	mov	r1, r2
 800873c:	2201      	movs	r2, #1
 800873e:	408a      	lsls	r2, r1
 8008740:	4611      	mov	r1, r2
 8008742:	4a56      	ldr	r2, [pc, #344]	@ (800889c <GPIO_INIT+0x23c>)
 8008744:	430b      	orrs	r3, r1
 8008746:	60d3      	str	r3, [r2, #12]
				EXTI->RTSR1 |= (1 << pGPIOhandle->GPIO_Config_t.GPIO_PinNumber)  ;
 8008748:	4b54      	ldr	r3, [pc, #336]	@ (800889c <GPIO_INIT+0x23c>)
 800874a:	689b      	ldr	r3, [r3, #8]
 800874c:	687a      	ldr	r2, [r7, #4]
 800874e:	7912      	ldrb	r2, [r2, #4]
 8008750:	4611      	mov	r1, r2
 8008752:	2201      	movs	r2, #1
 8008754:	408a      	lsls	r2, r1
 8008756:	4611      	mov	r1, r2
 8008758:	4a50      	ldr	r2, [pc, #320]	@ (800889c <GPIO_INIT+0x23c>)
 800875a:	430b      	orrs	r3, r1
 800875c:	6093      	str	r3, [r2, #8]
	}
}

//configure the output type
tempreg = 0;
 800875e:	2300      	movs	r3, #0
 8008760:	60fb      	str	r3, [r7, #12]
tempreg = (pGPIOhandle->GPIO_Config_t.GPIO_PinSpeed << (2 * pGPIOhandle->GPIO_Config_t.GPIO_PinNumber));
 8008762:	687b      	ldr	r3, [r7, #4]
 8008764:	799b      	ldrb	r3, [r3, #6]
 8008766:	461a      	mov	r2, r3
 8008768:	687b      	ldr	r3, [r7, #4]
 800876a:	791b      	ldrb	r3, [r3, #4]
 800876c:	005b      	lsls	r3, r3, #1
 800876e:	fa02 f303 	lsl.w	r3, r2, r3
 8008772:	60fb      	str	r3, [r7, #12]
pGPIOhandle->pGPIOx->OSPEEDR &= ~(0x3 << (2 * pGPIOhandle->GPIO_Config_t.GPIO_PinNumber));
 8008774:	687b      	ldr	r3, [r7, #4]
 8008776:	681b      	ldr	r3, [r3, #0]
 8008778:	689a      	ldr	r2, [r3, #8]
 800877a:	687b      	ldr	r3, [r7, #4]
 800877c:	791b      	ldrb	r3, [r3, #4]
 800877e:	005b      	lsls	r3, r3, #1
 8008780:	2103      	movs	r1, #3
 8008782:	fa01 f303 	lsl.w	r3, r1, r3
 8008786:	43db      	mvns	r3, r3
 8008788:	4619      	mov	r1, r3
 800878a:	687b      	ldr	r3, [r7, #4]
 800878c:	681b      	ldr	r3, [r3, #0]
 800878e:	400a      	ands	r2, r1
 8008790:	609a      	str	r2, [r3, #8]
pGPIOhandle->pGPIOx->OSPEEDR|= tempreg;
 8008792:	687b      	ldr	r3, [r7, #4]
 8008794:	681b      	ldr	r3, [r3, #0]
 8008796:	6899      	ldr	r1, [r3, #8]
 8008798:	687b      	ldr	r3, [r7, #4]
 800879a:	681b      	ldr	r3, [r3, #0]
 800879c:	68fa      	ldr	r2, [r7, #12]
 800879e:	430a      	orrs	r2, r1
 80087a0:	609a      	str	r2, [r3, #8]

//configure the pupd
tempreg =0;
 80087a2:	2300      	movs	r3, #0
 80087a4:	60fb      	str	r3, [r7, #12]
tempreg = (pGPIOhandle->GPIO_Config_t.GPIO_PinPuPdControl << (2 * pGPIOhandle->GPIO_Config_t.GPIO_PinNumber));
 80087a6:	687b      	ldr	r3, [r7, #4]
 80087a8:	79db      	ldrb	r3, [r3, #7]
 80087aa:	461a      	mov	r2, r3
 80087ac:	687b      	ldr	r3, [r7, #4]
 80087ae:	791b      	ldrb	r3, [r3, #4]
 80087b0:	005b      	lsls	r3, r3, #1
 80087b2:	fa02 f303 	lsl.w	r3, r2, r3
 80087b6:	60fb      	str	r3, [r7, #12]
pGPIOhandle->pGPIOx->PUPDR &= ~(0x3 << (2 * pGPIOhandle->GPIO_Config_t.GPIO_PinNumber));
 80087b8:	687b      	ldr	r3, [r7, #4]
 80087ba:	681b      	ldr	r3, [r3, #0]
 80087bc:	68da      	ldr	r2, [r3, #12]
 80087be:	687b      	ldr	r3, [r7, #4]
 80087c0:	791b      	ldrb	r3, [r3, #4]
 80087c2:	005b      	lsls	r3, r3, #1
 80087c4:	2103      	movs	r1, #3
 80087c6:	fa01 f303 	lsl.w	r3, r1, r3
 80087ca:	43db      	mvns	r3, r3
 80087cc:	4619      	mov	r1, r3
 80087ce:	687b      	ldr	r3, [r7, #4]
 80087d0:	681b      	ldr	r3, [r3, #0]
 80087d2:	400a      	ands	r2, r1
 80087d4:	60da      	str	r2, [r3, #12]
pGPIOhandle->pGPIOx->PUPDR |= tempreg;
 80087d6:	687b      	ldr	r3, [r7, #4]
 80087d8:	681b      	ldr	r3, [r3, #0]
 80087da:	68d9      	ldr	r1, [r3, #12]
 80087dc:	687b      	ldr	r3, [r7, #4]
 80087de:	681b      	ldr	r3, [r3, #0]
 80087e0:	68fa      	ldr	r2, [r7, #12]
 80087e2:	430a      	orrs	r2, r1
 80087e4:	60da      	str	r2, [r3, #12]


tempreg = 0;
 80087e6:	2300      	movs	r3, #0
 80087e8:	60fb      	str	r3, [r7, #12]
// output type
tempreg = (pGPIOhandle->GPIO_Config_t.GPIO_PinOPType <<  (pGPIOhandle->GPIO_Config_t.GPIO_PinNumber));
 80087ea:	687b      	ldr	r3, [r7, #4]
 80087ec:	7a1b      	ldrb	r3, [r3, #8]
 80087ee:	461a      	mov	r2, r3
 80087f0:	687b      	ldr	r3, [r7, #4]
 80087f2:	791b      	ldrb	r3, [r3, #4]
 80087f4:	fa02 f303 	lsl.w	r3, r2, r3
 80087f8:	60fb      	str	r3, [r7, #12]
pGPIOhandle->pGPIOx->OTYPER &= ~(0x1 << (pGPIOhandle->GPIO_Config_t.GPIO_PinNumber) );
 80087fa:	687b      	ldr	r3, [r7, #4]
 80087fc:	681b      	ldr	r3, [r3, #0]
 80087fe:	685a      	ldr	r2, [r3, #4]
 8008800:	687b      	ldr	r3, [r7, #4]
 8008802:	791b      	ldrb	r3, [r3, #4]
 8008804:	4619      	mov	r1, r3
 8008806:	2301      	movs	r3, #1
 8008808:	408b      	lsls	r3, r1
 800880a:	43db      	mvns	r3, r3
 800880c:	4619      	mov	r1, r3
 800880e:	687b      	ldr	r3, [r7, #4]
 8008810:	681b      	ldr	r3, [r3, #0]
 8008812:	400a      	ands	r2, r1
 8008814:	605a      	str	r2, [r3, #4]
pGPIOhandle->pGPIOx->OTYPER |= tempreg;
 8008816:	687b      	ldr	r3, [r7, #4]
 8008818:	681b      	ldr	r3, [r3, #0]
 800881a:	6859      	ldr	r1, [r3, #4]
 800881c:	687b      	ldr	r3, [r7, #4]
 800881e:	681b      	ldr	r3, [r3, #0]
 8008820:	68fa      	ldr	r2, [r7, #12]
 8008822:	430a      	orrs	r2, r1
 8008824:	605a      	str	r2, [r3, #4]

//configure the alternate functionility

if(pGPIOhandle->GPIO_Config_t.GPIO_PinMode ==GPIO_MODE_ALTERNATE)
 8008826:	687b      	ldr	r3, [r7, #4]
 8008828:	795b      	ldrb	r3, [r3, #5]
 800882a:	2b02      	cmp	r3, #2
 800882c:	d131      	bne.n	8008892 <GPIO_INIT+0x232>
{
	uint8_t temp1, temp2;
	temp1 = pGPIOhandle->GPIO_Config_t.GPIO_PinNumber /8;
 800882e:	687b      	ldr	r3, [r7, #4]
 8008830:	791b      	ldrb	r3, [r3, #4]
 8008832:	08db      	lsrs	r3, r3, #3
 8008834:	72fb      	strb	r3, [r7, #11]
	temp2 = pGPIOhandle->GPIO_Config_t.GPIO_PinNumber %8;
 8008836:	687b      	ldr	r3, [r7, #4]
 8008838:	791b      	ldrb	r3, [r3, #4]
 800883a:	f003 0307 	and.w	r3, r3, #7
 800883e:	72bb      	strb	r3, [r7, #10]
	pGPIOhandle->pGPIOx->AFR[temp1] &= ~(0xF << (4 * temp2));
 8008840:	687b      	ldr	r3, [r7, #4]
 8008842:	681b      	ldr	r3, [r3, #0]
 8008844:	7afa      	ldrb	r2, [r7, #11]
 8008846:	3208      	adds	r2, #8
 8008848:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 800884c:	7abb      	ldrb	r3, [r7, #10]
 800884e:	009b      	lsls	r3, r3, #2
 8008850:	220f      	movs	r2, #15
 8008852:	fa02 f303 	lsl.w	r3, r2, r3
 8008856:	43db      	mvns	r3, r3
 8008858:	4618      	mov	r0, r3
 800885a:	687b      	ldr	r3, [r7, #4]
 800885c:	681b      	ldr	r3, [r3, #0]
 800885e:	7afa      	ldrb	r2, [r7, #11]
 8008860:	4001      	ands	r1, r0
 8008862:	3208      	adds	r2, #8
 8008864:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	pGPIOhandle->pGPIOx->AFR[temp1] |= (pGPIOhandle->GPIO_Config_t.GPIO_PinAltFunMode << (4 * temp2));
 8008868:	687b      	ldr	r3, [r7, #4]
 800886a:	681b      	ldr	r3, [r3, #0]
 800886c:	7afa      	ldrb	r2, [r7, #11]
 800886e:	3208      	adds	r2, #8
 8008870:	f853 1022 	ldr.w	r1, [r3, r2, lsl #2]
 8008874:	687b      	ldr	r3, [r7, #4]
 8008876:	7a5b      	ldrb	r3, [r3, #9]
 8008878:	461a      	mov	r2, r3
 800887a:	7abb      	ldrb	r3, [r7, #10]
 800887c:	009b      	lsls	r3, r3, #2
 800887e:	fa02 f303 	lsl.w	r3, r2, r3
 8008882:	4618      	mov	r0, r3
 8008884:	687b      	ldr	r3, [r7, #4]
 8008886:	681b      	ldr	r3, [r3, #0]
 8008888:	7afa      	ldrb	r2, [r7, #11]
 800888a:	4301      	orrs	r1, r0
 800888c:	3208      	adds	r2, #8
 800888e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}

}
 8008892:	bf00      	nop
 8008894:	3710      	adds	r7, #16
 8008896:	46bd      	mov	sp, r7
 8008898:	bd80      	pop	{r7, pc}
 800889a:	bf00      	nop
 800889c:	40010400 	.word	0x40010400

080088a0 <GPIO_PERI_CTRL>:
		}
}

//peripheral control for the gpio
void GPIO_PERI_CTRL(GPIO_RegDef_t *pGPIOx, uint8_t ENORDI)
{
 80088a0:	b480      	push	{r7}
 80088a2:	b083      	sub	sp, #12
 80088a4:	af00      	add	r7, sp, #0
 80088a6:	6078      	str	r0, [r7, #4]
 80088a8:	460b      	mov	r3, r1
 80088aa:	70fb      	strb	r3, [r7, #3]
	if(ENORDI == ENABLE)
 80088ac:	78fb      	ldrb	r3, [r7, #3]
 80088ae:	2b01      	cmp	r3, #1
 80088b0:	d162      	bne.n	8008978 <GPIO_PERI_CTRL+0xd8>
	{
		if(pGPIOx == GPIOA)
 80088b2:	687b      	ldr	r3, [r7, #4]
 80088b4:	f1b3 4f90 	cmp.w	r3, #1207959552	@ 0x48000000
 80088b8:	d106      	bne.n	80088c8 <GPIO_PERI_CTRL+0x28>
		{
			GPIOA_CLK_EN;
 80088ba:	4b63      	ldr	r3, [pc, #396]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80088bc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80088be:	4a62      	ldr	r2, [pc, #392]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80088c0:	f043 0301 	orr.w	r3, r3, #1
 80088c4:	64d3      	str	r3, [r2, #76]	@ 0x4c
						{
							GPIOI_CLK_DI;
						}

	}
}
 80088c6:	e0b9      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
		else if(pGPIOx == GPIOB)
 80088c8:	687b      	ldr	r3, [r7, #4]
 80088ca:	4a60      	ldr	r2, [pc, #384]	@ (8008a4c <GPIO_PERI_CTRL+0x1ac>)
 80088cc:	4293      	cmp	r3, r2
 80088ce:	d106      	bne.n	80088de <GPIO_PERI_CTRL+0x3e>
			GPIOB_CLK_EN;
 80088d0:	4b5d      	ldr	r3, [pc, #372]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80088d2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80088d4:	4a5c      	ldr	r2, [pc, #368]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80088d6:	f043 0302 	orr.w	r3, r3, #2
 80088da:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 80088dc:	e0ae      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
		else if(pGPIOx == GPIOC)
 80088de:	687b      	ldr	r3, [r7, #4]
 80088e0:	4a5b      	ldr	r2, [pc, #364]	@ (8008a50 <GPIO_PERI_CTRL+0x1b0>)
 80088e2:	4293      	cmp	r3, r2
 80088e4:	d106      	bne.n	80088f4 <GPIO_PERI_CTRL+0x54>
					GPIOC_CLK_EN;
 80088e6:	4b58      	ldr	r3, [pc, #352]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80088e8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80088ea:	4a57      	ldr	r2, [pc, #348]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80088ec:	f043 0304 	orr.w	r3, r3, #4
 80088f0:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 80088f2:	e0a3      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
		else if(pGPIOx == GPIOD)
 80088f4:	687b      	ldr	r3, [r7, #4]
 80088f6:	4a57      	ldr	r2, [pc, #348]	@ (8008a54 <GPIO_PERI_CTRL+0x1b4>)
 80088f8:	4293      	cmp	r3, r2
 80088fa:	d106      	bne.n	800890a <GPIO_PERI_CTRL+0x6a>
					GPIOD_CLK_EN;
 80088fc:	4b52      	ldr	r3, [pc, #328]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80088fe:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8008900:	4a51      	ldr	r2, [pc, #324]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008902:	f043 0308 	orr.w	r3, r3, #8
 8008906:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 8008908:	e098      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
		else if(pGPIOx == GPIOE)
 800890a:	687b      	ldr	r3, [r7, #4]
 800890c:	4a52      	ldr	r2, [pc, #328]	@ (8008a58 <GPIO_PERI_CTRL+0x1b8>)
 800890e:	4293      	cmp	r3, r2
 8008910:	d106      	bne.n	8008920 <GPIO_PERI_CTRL+0x80>
					GPIOE_CLK_EN;
 8008912:	4b4d      	ldr	r3, [pc, #308]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008914:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8008916:	4a4c      	ldr	r2, [pc, #304]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008918:	f043 0310 	orr.w	r3, r3, #16
 800891c:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 800891e:	e08d      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
		else if(pGPIOx == GPIOF)
 8008920:	687b      	ldr	r3, [r7, #4]
 8008922:	4a4e      	ldr	r2, [pc, #312]	@ (8008a5c <GPIO_PERI_CTRL+0x1bc>)
 8008924:	4293      	cmp	r3, r2
 8008926:	d106      	bne.n	8008936 <GPIO_PERI_CTRL+0x96>
					GPIOF_CLK_EN;
 8008928:	4b47      	ldr	r3, [pc, #284]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 800892a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800892c:	4a46      	ldr	r2, [pc, #280]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 800892e:	f043 0320 	orr.w	r3, r3, #32
 8008932:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 8008934:	e082      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
		else if(pGPIOx == GPIOG)
 8008936:	687b      	ldr	r3, [r7, #4]
 8008938:	4a49      	ldr	r2, [pc, #292]	@ (8008a60 <GPIO_PERI_CTRL+0x1c0>)
 800893a:	4293      	cmp	r3, r2
 800893c:	d106      	bne.n	800894c <GPIO_PERI_CTRL+0xac>
					GPIOG_CLK_EN;
 800893e:	4b42      	ldr	r3, [pc, #264]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008940:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8008942:	4a41      	ldr	r2, [pc, #260]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008944:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
 8008948:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 800894a:	e077      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
		else if(pGPIOx == GPIOH)
 800894c:	687b      	ldr	r3, [r7, #4]
 800894e:	4a45      	ldr	r2, [pc, #276]	@ (8008a64 <GPIO_PERI_CTRL+0x1c4>)
 8008950:	4293      	cmp	r3, r2
 8008952:	d106      	bne.n	8008962 <GPIO_PERI_CTRL+0xc2>
					GPIOH_CLK_EN;
 8008954:	4b3c      	ldr	r3, [pc, #240]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008956:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8008958:	4a3b      	ldr	r2, [pc, #236]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 800895a:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800895e:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 8008960:	e06c      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
		else if(pGPIOx == GPIOI)
 8008962:	687b      	ldr	r3, [r7, #4]
 8008964:	4a40      	ldr	r2, [pc, #256]	@ (8008a68 <GPIO_PERI_CTRL+0x1c8>)
 8008966:	4293      	cmp	r3, r2
 8008968:	d168      	bne.n	8008a3c <GPIO_PERI_CTRL+0x19c>
					GPIOI_CLK_EN;
 800896a:	4b37      	ldr	r3, [pc, #220]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 800896c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800896e:	4a36      	ldr	r2, [pc, #216]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008970:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8008974:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 8008976:	e061      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
		if(pGPIOx == GPIOA)
 8008978:	687b      	ldr	r3, [r7, #4]
 800897a:	f1b3 4f90 	cmp.w	r3, #1207959552	@ 0x48000000
 800897e:	d106      	bne.n	800898e <GPIO_PERI_CTRL+0xee>
					GPIOA_CLK_DI;
 8008980:	4b31      	ldr	r3, [pc, #196]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008982:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8008984:	4a30      	ldr	r2, [pc, #192]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008986:	f023 0301 	bic.w	r3, r3, #1
 800898a:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 800898c:	e056      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
				else if(pGPIOx == GPIOB)
 800898e:	687b      	ldr	r3, [r7, #4]
 8008990:	4a2e      	ldr	r2, [pc, #184]	@ (8008a4c <GPIO_PERI_CTRL+0x1ac>)
 8008992:	4293      	cmp	r3, r2
 8008994:	d106      	bne.n	80089a4 <GPIO_PERI_CTRL+0x104>
					GPIOB_CLK_DI;
 8008996:	4b2c      	ldr	r3, [pc, #176]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008998:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 800899a:	4a2b      	ldr	r2, [pc, #172]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 800899c:	f023 0302 	bic.w	r3, r3, #2
 80089a0:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 80089a2:	e04b      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
				else if(pGPIOx == GPIOC)
 80089a4:	687b      	ldr	r3, [r7, #4]
 80089a6:	4a2a      	ldr	r2, [pc, #168]	@ (8008a50 <GPIO_PERI_CTRL+0x1b0>)
 80089a8:	4293      	cmp	r3, r2
 80089aa:	d106      	bne.n	80089ba <GPIO_PERI_CTRL+0x11a>
							GPIOC_CLK_DI;
 80089ac:	4b26      	ldr	r3, [pc, #152]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80089ae:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80089b0:	4a25      	ldr	r2, [pc, #148]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80089b2:	f023 0304 	bic.w	r3, r3, #4
 80089b6:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 80089b8:	e040      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
				else if(pGPIOx == GPIOD)
 80089ba:	687b      	ldr	r3, [r7, #4]
 80089bc:	4a25      	ldr	r2, [pc, #148]	@ (8008a54 <GPIO_PERI_CTRL+0x1b4>)
 80089be:	4293      	cmp	r3, r2
 80089c0:	d106      	bne.n	80089d0 <GPIO_PERI_CTRL+0x130>
							GPIOD_CLK_DI;
 80089c2:	4b21      	ldr	r3, [pc, #132]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80089c4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80089c6:	4a20      	ldr	r2, [pc, #128]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80089c8:	f023 0308 	bic.w	r3, r3, #8
 80089cc:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 80089ce:	e035      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
				else if(pGPIOx == GPIOE)
 80089d0:	687b      	ldr	r3, [r7, #4]
 80089d2:	4a21      	ldr	r2, [pc, #132]	@ (8008a58 <GPIO_PERI_CTRL+0x1b8>)
 80089d4:	4293      	cmp	r3, r2
 80089d6:	d106      	bne.n	80089e6 <GPIO_PERI_CTRL+0x146>
							GPIOE_CLK_DI;
 80089d8:	4b1b      	ldr	r3, [pc, #108]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80089da:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80089dc:	4a1a      	ldr	r2, [pc, #104]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80089de:	f023 0310 	bic.w	r3, r3, #16
 80089e2:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 80089e4:	e02a      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
				else if(pGPIOx == GPIOF)
 80089e6:	687b      	ldr	r3, [r7, #4]
 80089e8:	4a1c      	ldr	r2, [pc, #112]	@ (8008a5c <GPIO_PERI_CTRL+0x1bc>)
 80089ea:	4293      	cmp	r3, r2
 80089ec:	d106      	bne.n	80089fc <GPIO_PERI_CTRL+0x15c>
							GPIOF_CLK_DI;
 80089ee:	4b16      	ldr	r3, [pc, #88]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80089f0:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 80089f2:	4a15      	ldr	r2, [pc, #84]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 80089f4:	f023 0320 	bic.w	r3, r3, #32
 80089f8:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 80089fa:	e01f      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
				else if(pGPIOx == GPIOG)
 80089fc:	687b      	ldr	r3, [r7, #4]
 80089fe:	4a18      	ldr	r2, [pc, #96]	@ (8008a60 <GPIO_PERI_CTRL+0x1c0>)
 8008a00:	4293      	cmp	r3, r2
 8008a02:	d106      	bne.n	8008a12 <GPIO_PERI_CTRL+0x172>
							GPIOG_CLK_DI;
 8008a04:	4b10      	ldr	r3, [pc, #64]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008a06:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8008a08:	4a0f      	ldr	r2, [pc, #60]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008a0a:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 8008a0e:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 8008a10:	e014      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
				else if(pGPIOx == GPIOH)
 8008a12:	687b      	ldr	r3, [r7, #4]
 8008a14:	4a13      	ldr	r2, [pc, #76]	@ (8008a64 <GPIO_PERI_CTRL+0x1c4>)
 8008a16:	4293      	cmp	r3, r2
 8008a18:	d106      	bne.n	8008a28 <GPIO_PERI_CTRL+0x188>
							GPIOH_CLK_DI;
 8008a1a:	4b0b      	ldr	r3, [pc, #44]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008a1c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8008a1e:	4a0a      	ldr	r2, [pc, #40]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008a20:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8008a24:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 8008a26:	e009      	b.n	8008a3c <GPIO_PERI_CTRL+0x19c>
				else if(pGPIOx == GPIOI)
 8008a28:	687b      	ldr	r3, [r7, #4]
 8008a2a:	4a0f      	ldr	r2, [pc, #60]	@ (8008a68 <GPIO_PERI_CTRL+0x1c8>)
 8008a2c:	4293      	cmp	r3, r2
 8008a2e:	d105      	bne.n	8008a3c <GPIO_PERI_CTRL+0x19c>
							GPIOI_CLK_DI;
 8008a30:	4b05      	ldr	r3, [pc, #20]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008a32:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8008a34:	4a04      	ldr	r2, [pc, #16]	@ (8008a48 <GPIO_PERI_CTRL+0x1a8>)
 8008a36:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8008a3a:	64d3      	str	r3, [r2, #76]	@ 0x4c
}
 8008a3c:	bf00      	nop
 8008a3e:	370c      	adds	r7, #12
 8008a40:	46bd      	mov	sp, r7
 8008a42:	bc80      	pop	{r7}
 8008a44:	4770      	bx	lr
 8008a46:	bf00      	nop
 8008a48:	40021000 	.word	0x40021000
 8008a4c:	48000400 	.word	0x48000400
 8008a50:	48000800 	.word	0x48000800
 8008a54:	48000c00 	.word	0x48000c00
 8008a58:	48001000 	.word	0x48001000
 8008a5c:	48001400 	.word	0x48001400
 8008a60:	48001800 	.word	0x48001800
 8008a64:	48001c00 	.word	0x48001c00
 8008a68:	48002000 	.word	0x48002000

08008a6c <GPIO_WRITE_TO_INPUT_PIN>:
	read = (uint32_t)(pGPIOx->IDR);
	return read;
}

void GPIO_WRITE_TO_INPUT_PIN(GPIO_RegDef_t *pGPIOx,uint8_t pinnumber,uint8_t value)
{
 8008a6c:	b480      	push	{r7}
 8008a6e:	b083      	sub	sp, #12
 8008a70:	af00      	add	r7, sp, #0
 8008a72:	6078      	str	r0, [r7, #4]
 8008a74:	460b      	mov	r3, r1
 8008a76:	70fb      	strb	r3, [r7, #3]
 8008a78:	4613      	mov	r3, r2
 8008a7a:	70bb      	strb	r3, [r7, #2]
	if(value == GPIO_PIN_SET)
 8008a7c:	78bb      	ldrb	r3, [r7, #2]
 8008a7e:	2b01      	cmp	r3, #1
 8008a80:	d109      	bne.n	8008a96 <GPIO_WRITE_TO_INPUT_PIN+0x2a>
	{
		pGPIOx->ODR |= (1 << pinnumber);
 8008a82:	687b      	ldr	r3, [r7, #4]
 8008a84:	695b      	ldr	r3, [r3, #20]
 8008a86:	78fa      	ldrb	r2, [r7, #3]
 8008a88:	2101      	movs	r1, #1
 8008a8a:	fa01 f202 	lsl.w	r2, r1, r2
 8008a8e:	431a      	orrs	r2, r3
 8008a90:	687b      	ldr	r3, [r7, #4]
 8008a92:	615a      	str	r2, [r3, #20]
	{
		pGPIOx->ODR &= ~(1 << pinnumber);
	}


}
 8008a94:	e009      	b.n	8008aaa <GPIO_WRITE_TO_INPUT_PIN+0x3e>
		pGPIOx->ODR &= ~(1 << pinnumber);
 8008a96:	687b      	ldr	r3, [r7, #4]
 8008a98:	695b      	ldr	r3, [r3, #20]
 8008a9a:	78fa      	ldrb	r2, [r7, #3]
 8008a9c:	2101      	movs	r1, #1
 8008a9e:	fa01 f202 	lsl.w	r2, r1, r2
 8008aa2:	43d2      	mvns	r2, r2
 8008aa4:	401a      	ands	r2, r3
 8008aa6:	687b      	ldr	r3, [r7, #4]
 8008aa8:	615a      	str	r2, [r3, #20]
}
 8008aaa:	bf00      	nop
 8008aac:	370c      	adds	r7, #12
 8008aae:	46bd      	mov	sp, r7
 8008ab0:	bc80      	pop	{r7}
 8008ab2:	4770      	bx	lr

08008ab4 <USART_INIT>:

//APIS FOR THE USART

//init and deinit api's
void USART_INIT(USART_Handle_t *pUSARTHandle)
{   //clock for the usart
 8008ab4:	b580      	push	{r7, lr}
 8008ab6:	b084      	sub	sp, #16
 8008ab8:	af00      	add	r7, sp, #0
 8008aba:	6078      	str	r0, [r7, #4]
	USART_PER_CLK_CTRL(pUSARTHandle->pUSARTx, ENABLE);
 8008abc:	687b      	ldr	r3, [r7, #4]
 8008abe:	681b      	ldr	r3, [r3, #0]
 8008ac0:	2101      	movs	r1, #1
 8008ac2:	4618      	mov	r0, r3
 8008ac4:	f000 f87c 	bl	8008bc0 <USART_PER_CLK_CTRL>
	uint32_t tempreg=0;
 8008ac8:	2300      	movs	r3, #0
 8008aca:	60fb      	str	r3, [r7, #12]
	//configure the mode of the usart
	if(pUSARTHandle->USART_Config_t.USART_MODE ==  USART_MODE_ONLY_TX)
 8008acc:	687b      	ldr	r3, [r7, #4]
 8008ace:	791b      	ldrb	r3, [r3, #4]
 8008ad0:	2b00      	cmp	r3, #0
 8008ad2:	d104      	bne.n	8008ade <USART_INIT+0x2a>
	{
		tempreg |= (1<<3);
 8008ad4:	68fb      	ldr	r3, [r7, #12]
 8008ad6:	f043 0308 	orr.w	r3, r3, #8
 8008ada:	60fb      	str	r3, [r7, #12]
 8008adc:	e010      	b.n	8008b00 <USART_INIT+0x4c>
	}
	else if(pUSARTHandle->USART_Config_t.USART_MODE == USART_MODE_ONLY_RX)
 8008ade:	687b      	ldr	r3, [r7, #4]
 8008ae0:	791b      	ldrb	r3, [r3, #4]
 8008ae2:	2b01      	cmp	r3, #1
 8008ae4:	d104      	bne.n	8008af0 <USART_INIT+0x3c>
	{
		tempreg |= (1<<2);
 8008ae6:	68fb      	ldr	r3, [r7, #12]
 8008ae8:	f043 0304 	orr.w	r3, r3, #4
 8008aec:	60fb      	str	r3, [r7, #12]
 8008aee:	e007      	b.n	8008b00 <USART_INIT+0x4c>
	}
	else if(pUSARTHandle->USART_Config_t.USART_MODE == USART_MODE_TXRX)
 8008af0:	687b      	ldr	r3, [r7, #4]
 8008af2:	791b      	ldrb	r3, [r3, #4]
 8008af4:	2b02      	cmp	r3, #2
 8008af6:	d103      	bne.n	8008b00 <USART_INIT+0x4c>
	{
		tempreg  |= ((1<<3)|(1<<2));
 8008af8:	68fb      	ldr	r3, [r7, #12]
 8008afa:	f043 030c 	orr.w	r3, r3, #12
 8008afe:	60fb      	str	r3, [r7, #12]
	}

	//configure the length of the data
	tempreg |= ((pUSARTHandle->USART_Config_t.USART_WORD_LEN & 0x2) << 27) \
 8008b00:	687b      	ldr	r3, [r7, #4]
 8008b02:	7b5b      	ldrb	r3, [r3, #13]
 8008b04:	06db      	lsls	r3, r3, #27
 8008b06:	f003 5280 	and.w	r2, r3, #268435456	@ 0x10000000
	        |  ((pUSARTHandle->USART_Config_t.USART_WORD_LEN & 0x1) << 12);
 8008b0a:	687b      	ldr	r3, [r7, #4]
 8008b0c:	7b5b      	ldrb	r3, [r3, #13]
 8008b0e:	031b      	lsls	r3, r3, #12
 8008b10:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
 8008b14:	4313      	orrs	r3, r2
 8008b16:	461a      	mov	r2, r3
	tempreg |= ((pUSARTHandle->USART_Config_t.USART_WORD_LEN & 0x2) << 27) \
 8008b18:	68fb      	ldr	r3, [r7, #12]
 8008b1a:	4313      	orrs	r3, r2
 8008b1c:	60fb      	str	r3, [r7, #12]


	//configure the parity for the usart
	if(pUSARTHandle->USART_Config_t.USART_PARITY == USART_PARITY_EN_EVEN)
 8008b1e:	687b      	ldr	r3, [r7, #4]
 8008b20:	7b9b      	ldrb	r3, [r3, #14]
 8008b22:	2b01      	cmp	r3, #1
 8008b24:	d104      	bne.n	8008b30 <USART_INIT+0x7c>
	{
		tempreg|= (1<<10);
 8008b26:	68fb      	ldr	r3, [r7, #12]
 8008b28:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8008b2c:	60fb      	str	r3, [r7, #12]
 8008b2e:	e00b      	b.n	8008b48 <USART_INIT+0x94>
		//dont need to configure the even parity by default it is set to zero and enabled
	}
	else if (pUSARTHandle->USART_Config_t.USART_PARITY == USART_PARITY_EN_ODD)
 8008b30:	687b      	ldr	r3, [r7, #4]
 8008b32:	7b9b      	ldrb	r3, [r3, #14]
 8008b34:	2b00      	cmp	r3, #0
 8008b36:	d107      	bne.n	8008b48 <USART_INIT+0x94>
	{
		tempreg|= (1<<10);
 8008b38:	68fb      	ldr	r3, [r7, #12]
 8008b3a:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8008b3e:	60fb      	str	r3, [r7, #12]
		//enable the odd parity
		tempreg|= (1<<9);
 8008b40:	68fb      	ldr	r3, [r7, #12]
 8008b42:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8008b46:	60fb      	str	r3, [r7, #12]

	}

	//storing it in the cr1 reg
	pUSARTHandle->pUSARTx->CR1 = tempreg;
 8008b48:	687b      	ldr	r3, [r7, #4]
 8008b4a:	681b      	ldr	r3, [r3, #0]
 8008b4c:	68fa      	ldr	r2, [r7, #12]
 8008b4e:	601a      	str	r2, [r3, #0]

	//CONFIGURE THE CR2 REGISTER FOR NO. OF STOP BITS
	tempreg =0;
 8008b50:	2300      	movs	r3, #0
 8008b52:	60fb      	str	r3, [r7, #12]
	tempreg|= pUSARTHandle->USART_Config_t.USART_STOP_BITS << 12;
 8008b54:	687b      	ldr	r3, [r7, #4]
 8008b56:	7b1b      	ldrb	r3, [r3, #12]
 8008b58:	031b      	lsls	r3, r3, #12
 8008b5a:	68fa      	ldr	r2, [r7, #12]
 8008b5c:	4313      	orrs	r3, r2
 8008b5e:	60fb      	str	r3, [r7, #12]
	pUSARTHandle->pUSARTx->CR2 = tempreg;
 8008b60:	687b      	ldr	r3, [r7, #4]
 8008b62:	681b      	ldr	r3, [r3, #0]
 8008b64:	68fa      	ldr	r2, [r7, #12]
 8008b66:	605a      	str	r2, [r3, #4]

	//configure the cr3 register
	tempreg =0;
 8008b68:	2300      	movs	r3, #0
 8008b6a:	60fb      	str	r3, [r7, #12]
	 if(pUSARTHandle->USART_Config_t.USART_HW_FLOW_CTRL == USART_HW_FLOW_CTRL_CTS)
 8008b6c:	687b      	ldr	r3, [r7, #4]
 8008b6e:	7bdb      	ldrb	r3, [r3, #15]
 8008b70:	2b01      	cmp	r3, #1
 8008b72:	d104      	bne.n	8008b7e <USART_INIT+0xca>
	 {
		 tempreg |= (1<<9);
 8008b74:	68fb      	ldr	r3, [r7, #12]
 8008b76:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8008b7a:	60fb      	str	r3, [r7, #12]
 8008b7c:	e010      	b.n	8008ba0 <USART_INIT+0xec>
	 }
	 else if(pUSARTHandle->USART_Config_t.USART_HW_FLOW_CTRL == USART_HW_FLOW_CTRL_RTS)
 8008b7e:	687b      	ldr	r3, [r7, #4]
 8008b80:	7bdb      	ldrb	r3, [r3, #15]
 8008b82:	2b02      	cmp	r3, #2
 8008b84:	d104      	bne.n	8008b90 <USART_INIT+0xdc>
	 {
		 tempreg |= (1<<8);
 8008b86:	68fb      	ldr	r3, [r7, #12]
 8008b88:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8008b8c:	60fb      	str	r3, [r7, #12]
 8008b8e:	e007      	b.n	8008ba0 <USART_INIT+0xec>
	 }
	 else if(pUSARTHandle->USART_Config_t.USART_HW_FLOW_CTRL == USART_HW_FLOW_CTRL_CTS_RTS)
 8008b90:	687b      	ldr	r3, [r7, #4]
 8008b92:	7bdb      	ldrb	r3, [r3, #15]
 8008b94:	2b03      	cmp	r3, #3
 8008b96:	d103      	bne.n	8008ba0 <USART_INIT+0xec>
	 {
		 tempreg|= ((1<<9)|(1<<8));
 8008b98:	68fb      	ldr	r3, [r7, #12]
 8008b9a:	f443 7340 	orr.w	r3, r3, #768	@ 0x300
 8008b9e:	60fb      	str	r3, [r7, #12]
	 }

	 //program the cr3 reg
	 pUSARTHandle->pUSARTx->CR3 = tempreg;
 8008ba0:	687b      	ldr	r3, [r7, #4]
 8008ba2:	681b      	ldr	r3, [r3, #0]
 8008ba4:	68fa      	ldr	r2, [r7, #12]
 8008ba6:	609a      	str	r2, [r3, #8]

	 //configure the brr reg
	  USART_SetBaudRate(pUSARTHandle->pUSARTx, pUSARTHandle->USART_Config_t.USART_BAUD_RATE);
 8008ba8:	687b      	ldr	r3, [r7, #4]
 8008baa:	681a      	ldr	r2, [r3, #0]
 8008bac:	687b      	ldr	r3, [r7, #4]
 8008bae:	689b      	ldr	r3, [r3, #8]
 8008bb0:	4619      	mov	r1, r3
 8008bb2:	4610      	mov	r0, r2
 8008bb4:	f000 f90a 	bl	8008dcc <USART_SetBaudRate>



}
 8008bb8:	bf00      	nop
 8008bba:	3710      	adds	r7, #16
 8008bbc:	46bd      	mov	sp, r7
 8008bbe:	bd80      	pop	{r7, pc}

08008bc0 <USART_PER_CLK_CTRL>:
		}
}

//peripheral clk control
void USART_PER_CLK_CTRL(USART_RegDef_t *pUSARTx, uint8_t ENORDI)
{
 8008bc0:	b480      	push	{r7}
 8008bc2:	b083      	sub	sp, #12
 8008bc4:	af00      	add	r7, sp, #0
 8008bc6:	6078      	str	r0, [r7, #4]
 8008bc8:	460b      	mov	r3, r1
 8008bca:	70fb      	strb	r3, [r7, #3]
	if(ENORDI == ENABLE)
 8008bcc:	78fb      	ldrb	r3, [r7, #3]
 8008bce:	2b01      	cmp	r3, #1
 8008bd0:	d136      	bne.n	8008c40 <USART_PER_CLK_CTRL+0x80>
		{
			if(pUSARTx == USART1)
 8008bd2:	687b      	ldr	r3, [r7, #4]
 8008bd4:	4a38      	ldr	r2, [pc, #224]	@ (8008cb8 <USART_PER_CLK_CTRL+0xf8>)
 8008bd6:	4293      	cmp	r3, r2
 8008bd8:	d106      	bne.n	8008be8 <USART_PER_CLK_CTRL+0x28>
			{
				USART1_CLK_EN;
 8008bda:	4b38      	ldr	r3, [pc, #224]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008bdc:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8008bde:	4a37      	ldr	r2, [pc, #220]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008be0:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
 8008be4:	6613      	str	r3, [r2, #96]	@ 0x60
					else if (pUSARTx == UART5)
					{
						UART5_CLK_DI;
					}
	}
}
 8008be6:	e061      	b.n	8008cac <USART_PER_CLK_CTRL+0xec>
			else if(pUSARTx == USART2)
 8008be8:	687b      	ldr	r3, [r7, #4]
 8008bea:	4a35      	ldr	r2, [pc, #212]	@ (8008cc0 <USART_PER_CLK_CTRL+0x100>)
 8008bec:	4293      	cmp	r3, r2
 8008bee:	d106      	bne.n	8008bfe <USART_PER_CLK_CTRL+0x3e>
				USART2_CLK_EN;
 8008bf0:	4b32      	ldr	r3, [pc, #200]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008bf2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008bf4:	4a31      	ldr	r2, [pc, #196]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008bf6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
 8008bfa:	6593      	str	r3, [r2, #88]	@ 0x58
}
 8008bfc:	e056      	b.n	8008cac <USART_PER_CLK_CTRL+0xec>
			else if(pUSARTx == USART3)
 8008bfe:	687b      	ldr	r3, [r7, #4]
 8008c00:	4a30      	ldr	r2, [pc, #192]	@ (8008cc4 <USART_PER_CLK_CTRL+0x104>)
 8008c02:	4293      	cmp	r3, r2
 8008c04:	d106      	bne.n	8008c14 <USART_PER_CLK_CTRL+0x54>
				USART3_CLK_EN;
 8008c06:	4b2d      	ldr	r3, [pc, #180]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c08:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008c0a:	4a2c      	ldr	r2, [pc, #176]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c0c:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
 8008c10:	6593      	str	r3, [r2, #88]	@ 0x58
}
 8008c12:	e04b      	b.n	8008cac <USART_PER_CLK_CTRL+0xec>
			else if(pUSARTx == UART4)
 8008c14:	687b      	ldr	r3, [r7, #4]
 8008c16:	4a2c      	ldr	r2, [pc, #176]	@ (8008cc8 <USART_PER_CLK_CTRL+0x108>)
 8008c18:	4293      	cmp	r3, r2
 8008c1a:	d106      	bne.n	8008c2a <USART_PER_CLK_CTRL+0x6a>
				UART4_CLK_EN;
 8008c1c:	4b27      	ldr	r3, [pc, #156]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c1e:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008c20:	4a26      	ldr	r2, [pc, #152]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c22:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
 8008c26:	6593      	str	r3, [r2, #88]	@ 0x58
}
 8008c28:	e040      	b.n	8008cac <USART_PER_CLK_CTRL+0xec>
			else if (pUSARTx == UART5)
 8008c2a:	687b      	ldr	r3, [r7, #4]
 8008c2c:	4a27      	ldr	r2, [pc, #156]	@ (8008ccc <USART_PER_CLK_CTRL+0x10c>)
 8008c2e:	4293      	cmp	r3, r2
 8008c30:	d13c      	bne.n	8008cac <USART_PER_CLK_CTRL+0xec>
				UART5_CLK_EN;
 8008c32:	4b22      	ldr	r3, [pc, #136]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c34:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008c36:	4a21      	ldr	r2, [pc, #132]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c38:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8008c3c:	6593      	str	r3, [r2, #88]	@ 0x58
}
 8008c3e:	e035      	b.n	8008cac <USART_PER_CLK_CTRL+0xec>
		if(pUSARTx == USART1)
 8008c40:	687b      	ldr	r3, [r7, #4]
 8008c42:	4a1d      	ldr	r2, [pc, #116]	@ (8008cb8 <USART_PER_CLK_CTRL+0xf8>)
 8008c44:	4293      	cmp	r3, r2
 8008c46:	d106      	bne.n	8008c56 <USART_PER_CLK_CTRL+0x96>
						USART1_CLK_DI;
 8008c48:	4b1c      	ldr	r3, [pc, #112]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c4a:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 8008c4c:	4a1b      	ldr	r2, [pc, #108]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c4e:	f423 4380 	bic.w	r3, r3, #16384	@ 0x4000
 8008c52:	6613      	str	r3, [r2, #96]	@ 0x60
}
 8008c54:	e02a      	b.n	8008cac <USART_PER_CLK_CTRL+0xec>
					else if(pUSARTx == USART2)
 8008c56:	687b      	ldr	r3, [r7, #4]
 8008c58:	4a19      	ldr	r2, [pc, #100]	@ (8008cc0 <USART_PER_CLK_CTRL+0x100>)
 8008c5a:	4293      	cmp	r3, r2
 8008c5c:	d106      	bne.n	8008c6c <USART_PER_CLK_CTRL+0xac>
						USART2_CLK_DI;
 8008c5e:	4b17      	ldr	r3, [pc, #92]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c60:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008c62:	4a16      	ldr	r2, [pc, #88]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c64:	f423 3300 	bic.w	r3, r3, #131072	@ 0x20000
 8008c68:	6593      	str	r3, [r2, #88]	@ 0x58
}
 8008c6a:	e01f      	b.n	8008cac <USART_PER_CLK_CTRL+0xec>
					else if(pUSARTx == USART3)
 8008c6c:	687b      	ldr	r3, [r7, #4]
 8008c6e:	4a15      	ldr	r2, [pc, #84]	@ (8008cc4 <USART_PER_CLK_CTRL+0x104>)
 8008c70:	4293      	cmp	r3, r2
 8008c72:	d106      	bne.n	8008c82 <USART_PER_CLK_CTRL+0xc2>
						USART3_CLK_DI;
 8008c74:	4b11      	ldr	r3, [pc, #68]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c76:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008c78:	4a10      	ldr	r2, [pc, #64]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c7a:	f423 2380 	bic.w	r3, r3, #262144	@ 0x40000
 8008c7e:	6593      	str	r3, [r2, #88]	@ 0x58
}
 8008c80:	e014      	b.n	8008cac <USART_PER_CLK_CTRL+0xec>
					else if(pUSARTx == UART4)
 8008c82:	687b      	ldr	r3, [r7, #4]
 8008c84:	4a10      	ldr	r2, [pc, #64]	@ (8008cc8 <USART_PER_CLK_CTRL+0x108>)
 8008c86:	4293      	cmp	r3, r2
 8008c88:	d106      	bne.n	8008c98 <USART_PER_CLK_CTRL+0xd8>
						UART4_CLK_DI;
 8008c8a:	4b0c      	ldr	r3, [pc, #48]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c8c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008c8e:	4a0b      	ldr	r2, [pc, #44]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008c90:	f423 2300 	bic.w	r3, r3, #524288	@ 0x80000
 8008c94:	6593      	str	r3, [r2, #88]	@ 0x58
}
 8008c96:	e009      	b.n	8008cac <USART_PER_CLK_CTRL+0xec>
					else if (pUSARTx == UART5)
 8008c98:	687b      	ldr	r3, [r7, #4]
 8008c9a:	4a0c      	ldr	r2, [pc, #48]	@ (8008ccc <USART_PER_CLK_CTRL+0x10c>)
 8008c9c:	4293      	cmp	r3, r2
 8008c9e:	d105      	bne.n	8008cac <USART_PER_CLK_CTRL+0xec>
						UART5_CLK_DI;
 8008ca0:	4b06      	ldr	r3, [pc, #24]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008ca2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8008ca4:	4a05      	ldr	r2, [pc, #20]	@ (8008cbc <USART_PER_CLK_CTRL+0xfc>)
 8008ca6:	f423 1380 	bic.w	r3, r3, #1048576	@ 0x100000
 8008caa:	6593      	str	r3, [r2, #88]	@ 0x58
}
 8008cac:	bf00      	nop
 8008cae:	370c      	adds	r7, #12
 8008cb0:	46bd      	mov	sp, r7
 8008cb2:	bc80      	pop	{r7}
 8008cb4:	4770      	bx	lr
 8008cb6:	bf00      	nop
 8008cb8:	40013800 	.word	0x40013800
 8008cbc:	40021000 	.word	0x40021000
 8008cc0:	40004400 	.word	0x40004400
 8008cc4:	40004800 	.word	0x40004800
 8008cc8:	40004c00 	.word	0x40004c00
 8008ccc:	40005000 	.word	0x40005000

08008cd0 <USART_SEND_DATA>:

//data transfer and receiver
void USART_SEND_DATA(USART_Handle_t *pUSARTHandle,uint8_t *pTXBuffer, uint8_t len)
{
 8008cd0:	b580      	push	{r7, lr}
 8008cd2:	b086      	sub	sp, #24
 8008cd4:	af00      	add	r7, sp, #0
 8008cd6:	60f8      	str	r0, [r7, #12]
 8008cd8:	60b9      	str	r1, [r7, #8]
 8008cda:	4613      	mov	r3, r2
 8008cdc:	71fb      	strb	r3, [r7, #7]
uint16_t *pdata;

//transfer  the data till the length become zero
for(uint8_t i=0;i<len;i++)
 8008cde:	2300      	movs	r3, #0
 8008ce0:	75fb      	strb	r3, [r7, #23]
 8008ce2:	e031      	b.n	8008d48 <USART_SEND_DATA+0x78>
{
	//check transfer buffer is empty or not
	while(!USART_GetFlagStatus(pUSARTHandle->pUSARTx, USART_FLAG_TXE));
 8008ce4:	bf00      	nop
 8008ce6:	68fb      	ldr	r3, [r7, #12]
 8008ce8:	681b      	ldr	r3, [r3, #0]
 8008cea:	2180      	movs	r1, #128	@ 0x80
 8008cec:	4618      	mov	r0, r3
 8008cee:	f000 f859 	bl	8008da4 <USART_GetFlagStatus>
 8008cf2:	4603      	mov	r3, r0
 8008cf4:	2b00      	cmp	r3, #0
 8008cf6:	d0f6      	beq.n	8008ce6 <USART_SEND_DATA+0x16>

	if(pUSARTHandle->USART_Config_t.USART_WORD_LEN == USART_WORDLEN_9BITS)
 8008cf8:	68fb      	ldr	r3, [r7, #12]
 8008cfa:	7b5b      	ldrb	r3, [r3, #13]
 8008cfc:	2b01      	cmp	r3, #1
 8008cfe:	d118      	bne.n	8008d32 <USART_SEND_DATA+0x62>
	{
		pdata = (uint16_t*)pTXBuffer;
 8008d00:	68bb      	ldr	r3, [r7, #8]
 8008d02:	613b      	str	r3, [r7, #16]
		pUSARTHandle->pUSARTx->TDR = (*pdata & (uint16_t)0x01FF);
 8008d04:	693b      	ldr	r3, [r7, #16]
 8008d06:	881b      	ldrh	r3, [r3, #0]
 8008d08:	461a      	mov	r2, r3
 8008d0a:	68fb      	ldr	r3, [r7, #12]
 8008d0c:	681b      	ldr	r3, [r3, #0]
 8008d0e:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8008d12:	629a      	str	r2, [r3, #40]	@ 0x28

		if(pUSARTHandle->USART_Config_t.USART_PARITY == USART_PARITY_DISABLE)
 8008d14:	68fb      	ldr	r3, [r7, #12]
 8008d16:	7b9b      	ldrb	r3, [r3, #14]
 8008d18:	2b02      	cmp	r3, #2
 8008d1a:	d106      	bne.n	8008d2a <USART_SEND_DATA+0x5a>
		{
			pTXBuffer++;
 8008d1c:	68bb      	ldr	r3, [r7, #8]
 8008d1e:	3301      	adds	r3, #1
 8008d20:	60bb      	str	r3, [r7, #8]
			pTXBuffer++;
 8008d22:	68bb      	ldr	r3, [r7, #8]
 8008d24:	3301      	adds	r3, #1
 8008d26:	60bb      	str	r3, [r7, #8]
 8008d28:	e00b      	b.n	8008d42 <USART_SEND_DATA+0x72>
		}
		else
		{
			pTXBuffer++;
 8008d2a:	68bb      	ldr	r3, [r7, #8]
 8008d2c:	3301      	adds	r3, #1
 8008d2e:	60bb      	str	r3, [r7, #8]
 8008d30:	e007      	b.n	8008d42 <USART_SEND_DATA+0x72>
		}
	}
	else
	{
		//8 bit data transfer
		pUSARTHandle->pUSARTx->TDR = (*pTXBuffer & (uint8_t) 0xFF);
 8008d32:	68bb      	ldr	r3, [r7, #8]
 8008d34:	781a      	ldrb	r2, [r3, #0]
 8008d36:	68fb      	ldr	r3, [r7, #12]
 8008d38:	681b      	ldr	r3, [r3, #0]
 8008d3a:	629a      	str	r2, [r3, #40]	@ 0x28
		pTXBuffer++;
 8008d3c:	68bb      	ldr	r3, [r7, #8]
 8008d3e:	3301      	adds	r3, #1
 8008d40:	60bb      	str	r3, [r7, #8]
for(uint8_t i=0;i<len;i++)
 8008d42:	7dfb      	ldrb	r3, [r7, #23]
 8008d44:	3301      	adds	r3, #1
 8008d46:	75fb      	strb	r3, [r7, #23]
 8008d48:	7dfa      	ldrb	r2, [r7, #23]
 8008d4a:	79fb      	ldrb	r3, [r7, #7]
 8008d4c:	429a      	cmp	r2, r3
 8008d4e:	d3c9      	bcc.n	8008ce4 <USART_SEND_DATA+0x14>
	}


}
while(! USART_GetFlagStatus(pUSARTHandle->pUSARTx, USART_FLAG_TC));
 8008d50:	bf00      	nop
 8008d52:	68fb      	ldr	r3, [r7, #12]
 8008d54:	681b      	ldr	r3, [r3, #0]
 8008d56:	2140      	movs	r1, #64	@ 0x40
 8008d58:	4618      	mov	r0, r3
 8008d5a:	f000 f823 	bl	8008da4 <USART_GetFlagStatus>
 8008d5e:	4603      	mov	r3, r0
 8008d60:	2b00      	cmp	r3, #0
 8008d62:	d0f6      	beq.n	8008d52 <USART_SEND_DATA+0x82>
}
 8008d64:	bf00      	nop
 8008d66:	bf00      	nop
 8008d68:	3718      	adds	r7, #24
 8008d6a:	46bd      	mov	sp, r7
 8008d6c:	bd80      	pop	{r7, pc}

08008d6e <USART_PeripheralControl>:

/*
 * Other Peripheral Control APIs
 */
void USART_PeripheralControl(USART_RegDef_t *pUSARTx, uint8_t EnOrDi)
{
 8008d6e:	b480      	push	{r7}
 8008d70:	b083      	sub	sp, #12
 8008d72:	af00      	add	r7, sp, #0
 8008d74:	6078      	str	r0, [r7, #4]
 8008d76:	460b      	mov	r3, r1
 8008d78:	70fb      	strb	r3, [r7, #3]
	if(EnOrDi == ENABLE)
 8008d7a:	78fb      	ldrb	r3, [r7, #3]
 8008d7c:	2b01      	cmp	r3, #1
 8008d7e:	d106      	bne.n	8008d8e <USART_PeripheralControl+0x20>
	{
		pUSARTx->CR1 |= (1<<0);
 8008d80:	687b      	ldr	r3, [r7, #4]
 8008d82:	681b      	ldr	r3, [r3, #0]
 8008d84:	f043 0201 	orr.w	r2, r3, #1
 8008d88:	687b      	ldr	r3, [r7, #4]
 8008d8a:	601a      	str	r2, [r3, #0]
	}
	else
	{
		pUSARTx->CR1 &= ~(1<<0);
	}
}
 8008d8c:	e005      	b.n	8008d9a <USART_PeripheralControl+0x2c>
		pUSARTx->CR1 &= ~(1<<0);
 8008d8e:	687b      	ldr	r3, [r7, #4]
 8008d90:	681b      	ldr	r3, [r3, #0]
 8008d92:	f023 0201 	bic.w	r2, r3, #1
 8008d96:	687b      	ldr	r3, [r7, #4]
 8008d98:	601a      	str	r2, [r3, #0]
}
 8008d9a:	bf00      	nop
 8008d9c:	370c      	adds	r7, #12
 8008d9e:	46bd      	mov	sp, r7
 8008da0:	bc80      	pop	{r7}
 8008da2:	4770      	bx	lr

08008da4 <USART_GetFlagStatus>:
uint8_t USART_GetFlagStatus(USART_RegDef_t *pUSARTx , uint32_t FlagName)
{
 8008da4:	b480      	push	{r7}
 8008da6:	b083      	sub	sp, #12
 8008da8:	af00      	add	r7, sp, #0
 8008daa:	6078      	str	r0, [r7, #4]
 8008dac:	6039      	str	r1, [r7, #0]
	if(pUSARTx->ISR & FlagName)
 8008dae:	687b      	ldr	r3, [r7, #4]
 8008db0:	69da      	ldr	r2, [r3, #28]
 8008db2:	683b      	ldr	r3, [r7, #0]
 8008db4:	4013      	ands	r3, r2
 8008db6:	2b00      	cmp	r3, #0
 8008db8:	d001      	beq.n	8008dbe <USART_GetFlagStatus+0x1a>
	{
		return FLAG_SET;
 8008dba:	2301      	movs	r3, #1
 8008dbc:	e000      	b.n	8008dc0 <USART_GetFlagStatus+0x1c>
	}
	return FLAG_RESET;
 8008dbe:	2300      	movs	r3, #0
}
 8008dc0:	4618      	mov	r0, r3
 8008dc2:	370c      	adds	r7, #12
 8008dc4:	46bd      	mov	sp, r7
 8008dc6:	bc80      	pop	{r7}
 8008dc8:	4770      	bx	lr
	...

08008dcc <USART_SetBaudRate>:
void USART_SetBaudRate(USART_RegDef_t *pUSARTx, uint32_t BaudRate)
{
 8008dcc:	b580      	push	{r7, lr}
 8008dce:	b086      	sub	sp, #24
 8008dd0:	af00      	add	r7, sp, #0
 8008dd2:	6078      	str	r0, [r7, #4]
 8008dd4:	6039      	str	r1, [r7, #0]
    uint32_t PCLKx;
    uint32_t usartdiv;
    uint32_t brr;


    if(pUSARTx == USART1 )
 8008dd6:	687b      	ldr	r3, [r7, #4]
 8008dd8:	4a1a      	ldr	r2, [pc, #104]	@ (8008e44 <USART_SetBaudRate+0x78>)
 8008dda:	4293      	cmp	r3, r2
 8008ddc:	d103      	bne.n	8008de6 <USART_SetBaudRate+0x1a>
    {
        PCLKx = RCC_GetPCLK2Value(); // APB2
 8008dde:	f7ff fbd7 	bl	8008590 <RCC_GetPCLK2Value>
 8008de2:	6178      	str	r0, [r7, #20]
 8008de4:	e002      	b.n	8008dec <USART_SetBaudRate+0x20>
    }
    else
    {
        PCLKx = RCC_GetPCLK1Value(); // APB1
 8008de6:	f7ff fb6b 	bl	80084c0 <RCC_GetPCLK1Value>
 8008dea:	6178      	str	r0, [r7, #20]
    }

    // 2. Check OVER8 (CR1 bit 15)
    if(pUSARTx->CR1 & (1 << 15))  // oversampling by 8
 8008dec:	687b      	ldr	r3, [r7, #4]
 8008dee:	681b      	ldr	r3, [r3, #0]
 8008df0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
 8008df4:	2b00      	cmp	r3, #0
 8008df6:	d013      	beq.n	8008e20 <USART_SetBaudRate+0x54>
    {
        usartdiv = (2 * PCLKx + BaudRate/2) / BaudRate;  // rounded
 8008df8:	697b      	ldr	r3, [r7, #20]
 8008dfa:	005a      	lsls	r2, r3, #1
 8008dfc:	683b      	ldr	r3, [r7, #0]
 8008dfe:	085b      	lsrs	r3, r3, #1
 8008e00:	441a      	add	r2, r3
 8008e02:	683b      	ldr	r3, [r7, #0]
 8008e04:	fbb2 f3f3 	udiv	r3, r2, r3
 8008e08:	60fb      	str	r3, [r7, #12]
        brr = (usartdiv & 0xFFF0) | ((usartdiv & 0x000F) >> 1);
 8008e0a:	68fa      	ldr	r2, [r7, #12]
 8008e0c:	f64f 73f0 	movw	r3, #65520	@ 0xfff0
 8008e10:	4013      	ands	r3, r2
 8008e12:	68fa      	ldr	r2, [r7, #12]
 8008e14:	0852      	lsrs	r2, r2, #1
 8008e16:	f002 0207 	and.w	r2, r2, #7
 8008e1a:	4313      	orrs	r3, r2
 8008e1c:	613b      	str	r3, [r7, #16]
 8008e1e:	e009      	b.n	8008e34 <USART_SetBaudRate+0x68>
    }
    else // oversampling by 16
    {
        usartdiv = (PCLKx + BaudRate/2) / BaudRate; // rounded
 8008e20:	683b      	ldr	r3, [r7, #0]
 8008e22:	085a      	lsrs	r2, r3, #1
 8008e24:	697b      	ldr	r3, [r7, #20]
 8008e26:	441a      	add	r2, r3
 8008e28:	683b      	ldr	r3, [r7, #0]
 8008e2a:	fbb2 f3f3 	udiv	r3, r2, r3
 8008e2e:	60fb      	str	r3, [r7, #12]
        brr = usartdiv;
 8008e30:	68fb      	ldr	r3, [r7, #12]
 8008e32:	613b      	str	r3, [r7, #16]
    }

    // 3. Write BRR
    pUSARTx->BRR = brr;
 8008e34:	687b      	ldr	r3, [r7, #4]
 8008e36:	693a      	ldr	r2, [r7, #16]
 8008e38:	60da      	str	r2, [r3, #12]
}
 8008e3a:	bf00      	nop
 8008e3c:	3718      	adds	r7, #24
 8008e3e:	46bd      	mov	sp, r7
 8008e40:	bd80      	pop	{r7, pc}
 8008e42:	bf00      	nop
 8008e44:	40013800 	.word	0x40013800

08008e48 <USART_IRQHandling>:

}


void USART_IRQHandling(USART_Handle_t *pUSARTHandle)
{
 8008e48:	b580      	push	{r7, lr}
 8008e4a:	b086      	sub	sp, #24
 8008e4c:	af00      	add	r7, sp, #0
 8008e4e:	6078      	str	r0, [r7, #4]
	uint16_t *pdata;

/*************************Check for TC flag ********************************************/

    //Implement the code to check the state of TC bit in the ISR
	temp1 = pUSARTHandle->pUSARTx->ISR & ( 1 << 6);
 8008e50:	687b      	ldr	r3, [r7, #4]
 8008e52:	681b      	ldr	r3, [r3, #0]
 8008e54:	69db      	ldr	r3, [r3, #28]
 8008e56:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8008e5a:	617b      	str	r3, [r7, #20]

	 //Implement the code to check the state of TCEIE bit
	temp2 = pUSARTHandle->pUSARTx->CR1 & ( 1 << 6);
 8008e5c:	687b      	ldr	r3, [r7, #4]
 8008e5e:	681b      	ldr	r3, [r3, #0]
 8008e60:	681b      	ldr	r3, [r3, #0]
 8008e62:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8008e66:	613b      	str	r3, [r7, #16]

	if(temp1 && temp2 )
 8008e68:	697b      	ldr	r3, [r7, #20]
 8008e6a:	2b00      	cmp	r3, #0
 8008e6c:	d02f      	beq.n	8008ece <USART_IRQHandling+0x86>
 8008e6e:	693b      	ldr	r3, [r7, #16]
 8008e70:	2b00      	cmp	r3, #0
 8008e72:	d02c      	beq.n	8008ece <USART_IRQHandling+0x86>
	{
		//this interrupt is because of TC

		//close transmission and call application callback if TxLen is zero
		if ( pUSARTHandle->TXBusyState== USART_BUSY_IN_TX)
 8008e74:	687b      	ldr	r3, [r7, #4]
 8008e76:	7e9b      	ldrb	r3, [r3, #26]
 8008e78:	2b02      	cmp	r3, #2
 8008e7a:	d128      	bne.n	8008ece <USART_IRQHandling+0x86>
		{
			//Check the TxLen . If it is zero then close the data transmission
			if(! pUSARTHandle->TXLEN )
 8008e7c:	687b      	ldr	r3, [r7, #4]
 8008e7e:	7e1b      	ldrb	r3, [r3, #24]
 8008e80:	2b00      	cmp	r3, #0
 8008e82:	d124      	bne.n	8008ece <USART_IRQHandling+0x86>
			{
				//Implement the code to clear the TC flag

				 pUSARTHandle->pUSARTx->CR1 &= ~(1 << 7);
 8008e84:	687b      	ldr	r3, [r7, #4]
 8008e86:	681b      	ldr	r3, [r3, #0]
 8008e88:	681a      	ldr	r2, [r3, #0]
 8008e8a:	687b      	ldr	r3, [r7, #4]
 8008e8c:	681b      	ldr	r3, [r3, #0]
 8008e8e:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8008e92:	601a      	str	r2, [r3, #0]
				            pUSARTHandle->pUSARTx->CR1 &= ~(1 << 6);
 8008e94:	687b      	ldr	r3, [r7, #4]
 8008e96:	681b      	ldr	r3, [r3, #0]
 8008e98:	681a      	ldr	r2, [r3, #0]
 8008e9a:	687b      	ldr	r3, [r7, #4]
 8008e9c:	681b      	ldr	r3, [r3, #0]
 8008e9e:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8008ea2:	601a      	str	r2, [r3, #0]
				pUSARTHandle->pUSARTx->ICR |= ( 1 << 6);
 8008ea4:	687b      	ldr	r3, [r7, #4]
 8008ea6:	681b      	ldr	r3, [r3, #0]
 8008ea8:	6a1a      	ldr	r2, [r3, #32]
 8008eaa:	687b      	ldr	r3, [r7, #4]
 8008eac:	681b      	ldr	r3, [r3, #0]
 8008eae:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 8008eb2:	621a      	str	r2, [r3, #32]

				//Implement the code to clear the TCIE control bit

				//Reset the application state
				pUSARTHandle->TXBusyState = USART_READY;
 8008eb4:	687b      	ldr	r3, [r7, #4]
 8008eb6:	2200      	movs	r2, #0
 8008eb8:	769a      	strb	r2, [r3, #26]

				//Reset Buffer address to NULL
				pUSARTHandle->pTXBuffer = NULL;
 8008eba:	687b      	ldr	r3, [r7, #4]
 8008ebc:	2200      	movs	r2, #0
 8008ebe:	611a      	str	r2, [r3, #16]

				//Reset the length to zero
				pUSARTHandle->TXLEN = 0;
 8008ec0:	687b      	ldr	r3, [r7, #4]
 8008ec2:	2200      	movs	r2, #0
 8008ec4:	761a      	strb	r2, [r3, #24]

				//Call the application call back with event USART_EVENT_TX_CMPLT
				USART_ApplicationEventCallback(pUSARTHandle,USART_EVENT_TX_CMPLT);
 8008ec6:	2100      	movs	r1, #0
 8008ec8:	6878      	ldr	r0, [r7, #4]
 8008eca:	f000 f990 	bl	80091ee <USART_ApplicationEventCallback>
	}

/*************************Check for TXE flag ********************************************/

	//Implement the code to check the state of TXE bit in the SR
	temp1 = pUSARTHandle->pUSARTx->ISR & ( 1 << 7);
 8008ece:	687b      	ldr	r3, [r7, #4]
 8008ed0:	681b      	ldr	r3, [r3, #0]
 8008ed2:	69db      	ldr	r3, [r3, #28]
 8008ed4:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8008ed8:	617b      	str	r3, [r7, #20]

	//Implement the code to check the state of TXEIE bit in CR1
	temp2 = pUSARTHandle->pUSARTx->CR1 & ( 1 << 7);
 8008eda:	687b      	ldr	r3, [r7, #4]
 8008edc:	681b      	ldr	r3, [r3, #0]
 8008ede:	681b      	ldr	r3, [r3, #0]
 8008ee0:	f003 0380 	and.w	r3, r3, #128	@ 0x80
 8008ee4:	613b      	str	r3, [r7, #16]


	if(temp1 && temp2 )
 8008ee6:	697b      	ldr	r3, [r7, #20]
 8008ee8:	2b00      	cmp	r3, #0
 8008eea:	d057      	beq.n	8008f9c <USART_IRQHandling+0x154>
 8008eec:	693b      	ldr	r3, [r7, #16]
 8008eee:	2b00      	cmp	r3, #0
 8008ef0:	d054      	beq.n	8008f9c <USART_IRQHandling+0x154>
	{
		//this interrupt is because of TXE

		if(pUSARTHandle->TXBusyState == USART_BUSY_IN_TX)
 8008ef2:	687b      	ldr	r3, [r7, #4]
 8008ef4:	7e9b      	ldrb	r3, [r3, #26]
 8008ef6:	2b02      	cmp	r3, #2
 8008ef8:	d150      	bne.n	8008f9c <USART_IRQHandling+0x154>
		{
			//Keep sending data until Txlen reaches to zero
			if(pUSARTHandle->TXLEN > 0)
 8008efa:	687b      	ldr	r3, [r7, #4]
 8008efc:	7e1b      	ldrb	r3, [r3, #24]
 8008efe:	2b00      	cmp	r3, #0
 8008f00:	d040      	beq.n	8008f84 <USART_IRQHandling+0x13c>
			{
				//Check the USART_WordLength item for 9BIT or 8BIT in a frame
				if(pUSARTHandle->USART_Config_t.USART_WORD_LEN == USART_WORDLEN_9BITS)
 8008f02:	687b      	ldr	r3, [r7, #4]
 8008f04:	7b5b      	ldrb	r3, [r3, #13]
 8008f06:	2b01      	cmp	r3, #1
 8008f08:	d12b      	bne.n	8008f62 <USART_IRQHandling+0x11a>
				{
					//if 9BIT load the TDR with 2bytes masking  the bits other than first 9 bits
					pdata = (uint16_t*) pUSARTHandle->pTXBuffer;
 8008f0a:	687b      	ldr	r3, [r7, #4]
 8008f0c:	691b      	ldr	r3, [r3, #16]
 8008f0e:	60fb      	str	r3, [r7, #12]
					pUSARTHandle->pUSARTx->TDR = (*pdata & (uint16_t)0x01FF);
 8008f10:	68fb      	ldr	r3, [r7, #12]
 8008f12:	881b      	ldrh	r3, [r3, #0]
 8008f14:	461a      	mov	r2, r3
 8008f16:	687b      	ldr	r3, [r7, #4]
 8008f18:	681b      	ldr	r3, [r3, #0]
 8008f1a:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8008f1e:	629a      	str	r2, [r3, #40]	@ 0x28

					//check for USART_ParityControl
					if(pUSARTHandle->USART_Config_t.USART_PARITY == USART_PARITY_DISABLE)
 8008f20:	687b      	ldr	r3, [r7, #4]
 8008f22:	7b9b      	ldrb	r3, [r3, #14]
 8008f24:	2b02      	cmp	r3, #2
 8008f26:	d110      	bne.n	8008f4a <USART_IRQHandling+0x102>
					{
						//No parity is used in this transfer , so 9bits of user data will be sent
						//Implement the code to increment pTxBuffer twice
						pUSARTHandle->pTXBuffer++;
 8008f28:	687b      	ldr	r3, [r7, #4]
 8008f2a:	691b      	ldr	r3, [r3, #16]
 8008f2c:	1c5a      	adds	r2, r3, #1
 8008f2e:	687b      	ldr	r3, [r7, #4]
 8008f30:	611a      	str	r2, [r3, #16]
						pUSARTHandle->pTXBuffer++;
 8008f32:	687b      	ldr	r3, [r7, #4]
 8008f34:	691b      	ldr	r3, [r3, #16]
 8008f36:	1c5a      	adds	r2, r3, #1
 8008f38:	687b      	ldr	r3, [r7, #4]
 8008f3a:	611a      	str	r2, [r3, #16]
						pUSARTHandle->TXLEN-=2;
 8008f3c:	687b      	ldr	r3, [r7, #4]
 8008f3e:	7e1b      	ldrb	r3, [r3, #24]
 8008f40:	3b02      	subs	r3, #2
 8008f42:	b2da      	uxtb	r2, r3
 8008f44:	687b      	ldr	r3, [r7, #4]
 8008f46:	761a      	strb	r2, [r3, #24]
 8008f48:	e01c      	b.n	8008f84 <USART_IRQHandling+0x13c>
					}
					else
					{
						//Parity bit is used in this transfer . so 8bits of user data will be sent
						//The 9th bit will be replaced by parity bit by the hardware
						pUSARTHandle->pTXBuffer++;
 8008f4a:	687b      	ldr	r3, [r7, #4]
 8008f4c:	691b      	ldr	r3, [r3, #16]
 8008f4e:	1c5a      	adds	r2, r3, #1
 8008f50:	687b      	ldr	r3, [r7, #4]
 8008f52:	611a      	str	r2, [r3, #16]
						pUSARTHandle->TXLEN-=1;
 8008f54:	687b      	ldr	r3, [r7, #4]
 8008f56:	7e1b      	ldrb	r3, [r3, #24]
 8008f58:	3b01      	subs	r3, #1
 8008f5a:	b2da      	uxtb	r2, r3
 8008f5c:	687b      	ldr	r3, [r7, #4]
 8008f5e:	761a      	strb	r2, [r3, #24]
 8008f60:	e010      	b.n	8008f84 <USART_IRQHandling+0x13c>
					}
				}
				else
				{
					//This is 8bit data transfer
					pUSARTHandle->pUSARTx->TDR = (*pUSARTHandle->pTXBuffer  & (uint8_t)0xFF);
 8008f62:	687b      	ldr	r3, [r7, #4]
 8008f64:	691b      	ldr	r3, [r3, #16]
 8008f66:	781a      	ldrb	r2, [r3, #0]
 8008f68:	687b      	ldr	r3, [r7, #4]
 8008f6a:	681b      	ldr	r3, [r3, #0]
 8008f6c:	629a      	str	r2, [r3, #40]	@ 0x28

					//Implement the code to increment the buffer address
					pUSARTHandle->pTXBuffer++;
 8008f6e:	687b      	ldr	r3, [r7, #4]
 8008f70:	691b      	ldr	r3, [r3, #16]
 8008f72:	1c5a      	adds	r2, r3, #1
 8008f74:	687b      	ldr	r3, [r7, #4]
 8008f76:	611a      	str	r2, [r3, #16]
					pUSARTHandle->TXLEN-=1;
 8008f78:	687b      	ldr	r3, [r7, #4]
 8008f7a:	7e1b      	ldrb	r3, [r3, #24]
 8008f7c:	3b01      	subs	r3, #1
 8008f7e:	b2da      	uxtb	r2, r3
 8008f80:	687b      	ldr	r3, [r7, #4]
 8008f82:	761a      	strb	r2, [r3, #24]
				}

			}
			if (pUSARTHandle->TXLEN == 0 )
 8008f84:	687b      	ldr	r3, [r7, #4]
 8008f86:	7e1b      	ldrb	r3, [r3, #24]
 8008f88:	2b00      	cmp	r3, #0
 8008f8a:	d107      	bne.n	8008f9c <USART_IRQHandling+0x154>
			{
				//TxLen is zero
				//Implement the code to clear the TXEIE bit (disable interrupt for TXE flag )
				pUSARTHandle->pUSARTx->CR1 &= ~( 1 << 7);
 8008f8c:	687b      	ldr	r3, [r7, #4]
 8008f8e:	681b      	ldr	r3, [r3, #0]
 8008f90:	681a      	ldr	r2, [r3, #0]
 8008f92:	687b      	ldr	r3, [r7, #4]
 8008f94:	681b      	ldr	r3, [r3, #0]
 8008f96:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8008f9a:	601a      	str	r2, [r3, #0]
		}
	}

/*************************Check for RXNE flag ********************************************/

	temp1 = pUSARTHandle->pUSARTx->ISR & ( 1 << 5);
 8008f9c:	687b      	ldr	r3, [r7, #4]
 8008f9e:	681b      	ldr	r3, [r3, #0]
 8008fa0:	69db      	ldr	r3, [r3, #28]
 8008fa2:	f003 0320 	and.w	r3, r3, #32
 8008fa6:	617b      	str	r3, [r7, #20]
	temp2 = pUSARTHandle->pUSARTx->CR1 & ( 1 << 5);
 8008fa8:	687b      	ldr	r3, [r7, #4]
 8008faa:	681b      	ldr	r3, [r3, #0]
 8008fac:	681b      	ldr	r3, [r3, #0]
 8008fae:	f003 0320 	and.w	r3, r3, #32
 8008fb2:	613b      	str	r3, [r7, #16]


	if(temp1 && temp2 )
 8008fb4:	697b      	ldr	r3, [r7, #20]
 8008fb6:	2b00      	cmp	r3, #0
 8008fb8:	d074      	beq.n	80090a4 <USART_IRQHandling+0x25c>
 8008fba:	693b      	ldr	r3, [r7, #16]
 8008fbc:	2b00      	cmp	r3, #0
 8008fbe:	d071      	beq.n	80090a4 <USART_IRQHandling+0x25c>
	{
		//this interrupt is because of rxne
		if(pUSARTHandle->RXBusyState == USART_BUSY_IN_RX)
 8008fc0:	687b      	ldr	r3, [r7, #4]
 8008fc2:	7edb      	ldrb	r3, [r3, #27]
 8008fc4:	2b01      	cmp	r3, #1
 8008fc6:	d16d      	bne.n	80090a4 <USART_IRQHandling+0x25c>
		{
			if(pUSARTHandle->RXLEN > 0)
 8008fc8:	687b      	ldr	r3, [r7, #4]
 8008fca:	7e5b      	ldrb	r3, [r3, #25]
 8008fcc:	2b00      	cmp	r3, #0
 8008fce:	d056      	beq.n	800907e <USART_IRQHandling+0x236>
			{
				//Check the USART_WordLength to decide whether we are going to receive 9bit of data in a frame or 8 bit
				if(pUSARTHandle->USART_Config_t.USART_WORD_LEN == USART_WORDLEN_9BITS)
 8008fd0:	687b      	ldr	r3, [r7, #4]
 8008fd2:	7b5b      	ldrb	r3, [r3, #13]
 8008fd4:	2b01      	cmp	r3, #1
 8008fd6:	d131      	bne.n	800903c <USART_IRQHandling+0x1f4>
				{
					//We are going to receive 9bit data in a frame

					//Now, check are we using USART_ParityControl control or not
					if(pUSARTHandle->USART_Config_t.USART_PARITY == USART_PARITY_DISABLE)
 8008fd8:	687b      	ldr	r3, [r7, #4]
 8008fda:	7b9b      	ldrb	r3, [r3, #14]
 8008fdc:	2b02      	cmp	r3, #2
 8008fde:	d11a      	bne.n	8009016 <USART_IRQHandling+0x1ce>
					{
						//No parity is used , so all 9bits will be of user data

						//read only first 9 bits so mask the RDR with 0x01FF
						*((uint16_t*) pUSARTHandle->pRXBuffer) = (pUSARTHandle->pUSARTx->RDR  & (uint16_t)0x01FF);
 8008fe0:	687b      	ldr	r3, [r7, #4]
 8008fe2:	681b      	ldr	r3, [r3, #0]
 8008fe4:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 8008fe6:	b29a      	uxth	r2, r3
 8008fe8:	687b      	ldr	r3, [r7, #4]
 8008fea:	695b      	ldr	r3, [r3, #20]
 8008fec:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8008ff0:	b292      	uxth	r2, r2
 8008ff2:	801a      	strh	r2, [r3, #0]

						//Now increment the pRxBuffer two times
						pUSARTHandle->pRXBuffer++;
 8008ff4:	687b      	ldr	r3, [r7, #4]
 8008ff6:	695b      	ldr	r3, [r3, #20]
 8008ff8:	1c5a      	adds	r2, r3, #1
 8008ffa:	687b      	ldr	r3, [r7, #4]
 8008ffc:	615a      	str	r2, [r3, #20]
						pUSARTHandle->pRXBuffer++;
 8008ffe:	687b      	ldr	r3, [r7, #4]
 8009000:	695b      	ldr	r3, [r3, #20]
 8009002:	1c5a      	adds	r2, r3, #1
 8009004:	687b      	ldr	r3, [r7, #4]
 8009006:	615a      	str	r2, [r3, #20]
						pUSARTHandle->RXLEN-=2;
 8009008:	687b      	ldr	r3, [r7, #4]
 800900a:	7e5b      	ldrb	r3, [r3, #25]
 800900c:	3b02      	subs	r3, #2
 800900e:	b2da      	uxtb	r2, r3
 8009010:	687b      	ldr	r3, [r7, #4]
 8009012:	765a      	strb	r2, [r3, #25]
 8009014:	e033      	b.n	800907e <USART_IRQHandling+0x236>
					}
					else
					{
						//Parity is used, so 8bits will be of user data and 1 bit is parity
						 *pUSARTHandle->pRXBuffer = (pUSARTHandle->pUSARTx->RDR  & (uint8_t)0xFF);
 8009016:	687b      	ldr	r3, [r7, #4]
 8009018:	681b      	ldr	r3, [r3, #0]
 800901a:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800901c:	687b      	ldr	r3, [r7, #4]
 800901e:	695b      	ldr	r3, [r3, #20]
 8009020:	b2d2      	uxtb	r2, r2
 8009022:	701a      	strb	r2, [r3, #0]
						 pUSARTHandle->pRXBuffer++;
 8009024:	687b      	ldr	r3, [r7, #4]
 8009026:	695b      	ldr	r3, [r3, #20]
 8009028:	1c5a      	adds	r2, r3, #1
 800902a:	687b      	ldr	r3, [r7, #4]
 800902c:	615a      	str	r2, [r3, #20]
						 pUSARTHandle->RXLEN-=1;
 800902e:	687b      	ldr	r3, [r7, #4]
 8009030:	7e5b      	ldrb	r3, [r3, #25]
 8009032:	3b01      	subs	r3, #1
 8009034:	b2da      	uxtb	r2, r3
 8009036:	687b      	ldr	r3, [r7, #4]
 8009038:	765a      	strb	r2, [r3, #25]
 800903a:	e020      	b.n	800907e <USART_IRQHandling+0x236>
				else
				{
					//We are going to receive 8bit data in a frame

					//Now, check are we using USART_ParityControl control or not
					if(pUSARTHandle->USART_Config_t.USART_PARITY == USART_PARITY_DISABLE)
 800903c:	687b      	ldr	r3, [r7, #4]
 800903e:	7b9b      	ldrb	r3, [r3, #14]
 8009040:	2b02      	cmp	r3, #2
 8009042:	d107      	bne.n	8009054 <USART_IRQHandling+0x20c>
					{
						//No parity is used , so all 8bits will be of user data

						//read 8 bits from DR
						 *pUSARTHandle->pRXBuffer = (uint8_t) (pUSARTHandle->pUSARTx->RDR  & (uint8_t)0xFF);
 8009044:	687b      	ldr	r3, [r7, #4]
 8009046:	681b      	ldr	r3, [r3, #0]
 8009048:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
 800904a:	687b      	ldr	r3, [r7, #4]
 800904c:	695b      	ldr	r3, [r3, #20]
 800904e:	b2d2      	uxtb	r2, r2
 8009050:	701a      	strb	r2, [r3, #0]
 8009052:	e009      	b.n	8009068 <USART_IRQHandling+0x220>
					else
					{
						//Parity is used, so , 7 bits will be of user data and 1 bit is parity

						//read only 7 bits , hence mask the DR with 0X7F
						 *pUSARTHandle->pRXBuffer = (uint8_t) (pUSARTHandle->pUSARTx->RDR  & (uint8_t)0x7F);
 8009054:	687b      	ldr	r3, [r7, #4]
 8009056:	681b      	ldr	r3, [r3, #0]
 8009058:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
 800905a:	b2da      	uxtb	r2, r3
 800905c:	687b      	ldr	r3, [r7, #4]
 800905e:	695b      	ldr	r3, [r3, #20]
 8009060:	f002 027f 	and.w	r2, r2, #127	@ 0x7f
 8009064:	b2d2      	uxtb	r2, r2
 8009066:	701a      	strb	r2, [r3, #0]

					}

					//Now , increment the pRxBuffer
					pUSARTHandle->pRXBuffer++;
 8009068:	687b      	ldr	r3, [r7, #4]
 800906a:	695b      	ldr	r3, [r3, #20]
 800906c:	1c5a      	adds	r2, r3, #1
 800906e:	687b      	ldr	r3, [r7, #4]
 8009070:	615a      	str	r2, [r3, #20]
					 pUSARTHandle->RXLEN-=1;
 8009072:	687b      	ldr	r3, [r7, #4]
 8009074:	7e5b      	ldrb	r3, [r3, #25]
 8009076:	3b01      	subs	r3, #1
 8009078:	b2da      	uxtb	r2, r3
 800907a:	687b      	ldr	r3, [r7, #4]
 800907c:	765a      	strb	r2, [r3, #25]
				}


			}//if of >0

			if(! pUSARTHandle->RXLEN)
 800907e:	687b      	ldr	r3, [r7, #4]
 8009080:	7e5b      	ldrb	r3, [r3, #25]
 8009082:	2b00      	cmp	r3, #0
 8009084:	d10e      	bne.n	80090a4 <USART_IRQHandling+0x25c>
			{
				//disable the rxne
				pUSARTHandle->pUSARTx->CR1 &= ~( 1 << 5);
 8009086:	687b      	ldr	r3, [r7, #4]
 8009088:	681b      	ldr	r3, [r3, #0]
 800908a:	681a      	ldr	r2, [r3, #0]
 800908c:	687b      	ldr	r3, [r7, #4]
 800908e:	681b      	ldr	r3, [r3, #0]
 8009090:	f022 0220 	bic.w	r2, r2, #32
 8009094:	601a      	str	r2, [r3, #0]
				pUSARTHandle->RXBusyState = USART_READY;
 8009096:	687b      	ldr	r3, [r7, #4]
 8009098:	2200      	movs	r2, #0
 800909a:	76da      	strb	r2, [r3, #27]
				USART_ApplicationEventCallback(pUSARTHandle,USART_EVENT_RX_CMPLT);
 800909c:	2101      	movs	r1, #1
 800909e:	6878      	ldr	r0, [r7, #4]
 80090a0:	f000 f8a5 	bl	80091ee <USART_ApplicationEventCallback>

/*************************Check for CTS flag ********************************************/


	//Implement the code to check the status of CTS bit in the ISR
	temp1 = pUSARTHandle->pUSARTx->ISR & ( 1 << 10);
 80090a4:	687b      	ldr	r3, [r7, #4]
 80090a6:	681b      	ldr	r3, [r3, #0]
 80090a8:	69db      	ldr	r3, [r3, #28]
 80090aa:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80090ae:	617b      	str	r3, [r7, #20]

	//Implement the code to check the state of CTSE bit in CR3
	temp2 = pUSARTHandle->pUSARTx->CR3 & ( 1 << 9);
 80090b0:	687b      	ldr	r3, [r7, #4]
 80090b2:	681b      	ldr	r3, [r3, #0]
 80090b4:	689b      	ldr	r3, [r3, #8]
 80090b6:	f403 7300 	and.w	r3, r3, #512	@ 0x200
 80090ba:	613b      	str	r3, [r7, #16]

	//Implement the code to check the state of CTSIE bit in CR3
	temp3 = pUSARTHandle->pUSARTx->CR3 & ( 1 << 10);
 80090bc:	687b      	ldr	r3, [r7, #4]
 80090be:	681b      	ldr	r3, [r3, #0]
 80090c0:	689b      	ldr	r3, [r3, #8]
 80090c2:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
 80090c6:	60bb      	str	r3, [r7, #8]


	if(temp1  && temp2 )
 80090c8:	697b      	ldr	r3, [r7, #20]
 80090ca:	2b00      	cmp	r3, #0
 80090cc:	d00e      	beq.n	80090ec <USART_IRQHandling+0x2a4>
 80090ce:	693b      	ldr	r3, [r7, #16]
 80090d0:	2b00      	cmp	r3, #0
 80090d2:	d00b      	beq.n	80090ec <USART_IRQHandling+0x2a4>
	{
		//Implement the code to clear the CTS flag in ISR
		pUSARTHandle->pUSARTx->ICR |= ( 1 << 9);
 80090d4:	687b      	ldr	r3, [r7, #4]
 80090d6:	681b      	ldr	r3, [r3, #0]
 80090d8:	6a1a      	ldr	r2, [r3, #32]
 80090da:	687b      	ldr	r3, [r7, #4]
 80090dc:	681b      	ldr	r3, [r3, #0]
 80090de:	f442 7200 	orr.w	r2, r2, #512	@ 0x200
 80090e2:	621a      	str	r2, [r3, #32]

		//this interrupt is because of cts
		USART_ApplicationEventCallback(pUSARTHandle,USART_EVENT_CTS);
 80090e4:	2103      	movs	r1, #3
 80090e6:	6878      	ldr	r0, [r7, #4]
 80090e8:	f000 f881 	bl	80091ee <USART_ApplicationEventCallback>
	}

/*************************Check for IDLE detection flag ********************************************/

	//Implement the code to check the status of IDLE flag bit in the ISR
	temp1 = pUSARTHandle->pUSARTx->ISR & ( 1 << 4);
 80090ec:	687b      	ldr	r3, [r7, #4]
 80090ee:	681b      	ldr	r3, [r3, #0]
 80090f0:	69db      	ldr	r3, [r3, #28]
 80090f2:	f003 0310 	and.w	r3, r3, #16
 80090f6:	617b      	str	r3, [r7, #20]

	//Implement the code to check the state of IDLEIE bit in CR1
	temp2 = pUSARTHandle->pUSARTx->CR1 & ( 1 << 4);
 80090f8:	687b      	ldr	r3, [r7, #4]
 80090fa:	681b      	ldr	r3, [r3, #0]
 80090fc:	681b      	ldr	r3, [r3, #0]
 80090fe:	f003 0310 	and.w	r3, r3, #16
 8009102:	613b      	str	r3, [r7, #16]


	if(temp1 && temp2)
 8009104:	697b      	ldr	r3, [r7, #20]
 8009106:	2b00      	cmp	r3, #0
 8009108:	d00f      	beq.n	800912a <USART_IRQHandling+0x2e2>
 800910a:	693b      	ldr	r3, [r7, #16]
 800910c:	2b00      	cmp	r3, #0
 800910e:	d00c      	beq.n	800912a <USART_IRQHandling+0x2e2>
	{
		//Implement the code to clear the IDLE flag.
		temp1 = pUSARTHandle->pUSARTx->ICR |=( 1 <<4);
 8009110:	687b      	ldr	r3, [r7, #4]
 8009112:	681b      	ldr	r3, [r3, #0]
 8009114:	6a1b      	ldr	r3, [r3, #32]
 8009116:	687a      	ldr	r2, [r7, #4]
 8009118:	6812      	ldr	r2, [r2, #0]
 800911a:	f043 0310 	orr.w	r3, r3, #16
 800911e:	6213      	str	r3, [r2, #32]
 8009120:	617b      	str	r3, [r7, #20]

		//this interrupt is because of idle
		USART_ApplicationEventCallback(pUSARTHandle,USART_EVENT_IDLE);
 8009122:	2102      	movs	r1, #2
 8009124:	6878      	ldr	r0, [r7, #4]
 8009126:	f000 f862 	bl	80091ee <USART_ApplicationEventCallback>
	}

/*************************Check for Overrun detection flag ********************************************/

	//Implement the code to check the status of ORE flag  in the ISR
	temp1 = pUSARTHandle->pUSARTx->ISR & (1 << 3);
 800912a:	687b      	ldr	r3, [r7, #4]
 800912c:	681b      	ldr	r3, [r3, #0]
 800912e:	69db      	ldr	r3, [r3, #28]
 8009130:	f003 0308 	and.w	r3, r3, #8
 8009134:	617b      	str	r3, [r7, #20]

	//Implement the code to check the status of RXNEIE  bit in the CR1
	temp2 = pUSARTHandle->pUSARTx->CR1 & (1 << 5);
 8009136:	687b      	ldr	r3, [r7, #4]
 8009138:	681b      	ldr	r3, [r3, #0]
 800913a:	681b      	ldr	r3, [r3, #0]
 800913c:	f003 0320 	and.w	r3, r3, #32
 8009140:	613b      	str	r3, [r7, #16]


	if(temp1  && temp2 )
 8009142:	697b      	ldr	r3, [r7, #20]
 8009144:	2b00      	cmp	r3, #0
 8009146:	d00e      	beq.n	8009166 <USART_IRQHandling+0x31e>
 8009148:	693b      	ldr	r3, [r7, #16]
 800914a:	2b00      	cmp	r3, #0
 800914c:	d00b      	beq.n	8009166 <USART_IRQHandling+0x31e>
	{
		pUSARTHandle->pUSARTx->ICR |= (1<< 3);
 800914e:	687b      	ldr	r3, [r7, #4]
 8009150:	681b      	ldr	r3, [r3, #0]
 8009152:	6a1a      	ldr	r2, [r3, #32]
 8009154:	687b      	ldr	r3, [r7, #4]
 8009156:	681b      	ldr	r3, [r3, #0]
 8009158:	f042 0208 	orr.w	r2, r2, #8
 800915c:	621a      	str	r2, [r3, #32]

		//this interrupt is because of Overrun error
		USART_ApplicationEventCallback(pUSARTHandle,USART_ERR_ORE);
 800915e:	2107      	movs	r1, #7
 8009160:	6878      	ldr	r0, [r7, #4]
 8009162:	f000 f844 	bl	80091ee <USART_ApplicationEventCallback>

//Noise Flag, Overrun error and Framing Error in multibuffer communication
//We dont discuss multibuffer communication in this course. please refer to the RM
//The blow code will get executed in only if multibuffer mode is used.

	temp2 =  pUSARTHandle->pUSARTx->CR3 & ( 1 << 0) ;
 8009166:	687b      	ldr	r3, [r7, #4]
 8009168:	681b      	ldr	r3, [r3, #0]
 800916a:	689b      	ldr	r3, [r3, #8]
 800916c:	f003 0301 	and.w	r3, r3, #1
 8009170:	613b      	str	r3, [r7, #16]

	if(temp2 )
 8009172:	693b      	ldr	r3, [r7, #16]
 8009174:	2b00      	cmp	r3, #0
 8009176:	d036      	beq.n	80091e6 <USART_IRQHandling+0x39e>
	{
		temp1 = pUSARTHandle->pUSARTx->ISR;
 8009178:	687b      	ldr	r3, [r7, #4]
 800917a:	681b      	ldr	r3, [r3, #0]
 800917c:	69db      	ldr	r3, [r3, #28]
 800917e:	617b      	str	r3, [r7, #20]
		if(temp1 & ( 1 << 1))
 8009180:	697b      	ldr	r3, [r7, #20]
 8009182:	f003 0302 	and.w	r3, r3, #2
 8009186:	2b00      	cmp	r3, #0
 8009188:	d00b      	beq.n	80091a2 <USART_IRQHandling+0x35a>
		{
			//CLEARING THIS REGISTER
			pUSARTHandle->pUSARTx->ICR |= (1 <<1);
 800918a:	687b      	ldr	r3, [r7, #4]
 800918c:	681b      	ldr	r3, [r3, #0]
 800918e:	6a1a      	ldr	r2, [r3, #32]
 8009190:	687b      	ldr	r3, [r7, #4]
 8009192:	681b      	ldr	r3, [r3, #0]
 8009194:	f042 0202 	orr.w	r2, r2, #2
 8009198:	621a      	str	r2, [r3, #32]
			USART_ApplicationEventCallback(pUSARTHandle,USART_ERR_FE);
 800919a:	2105      	movs	r1, #5
 800919c:	6878      	ldr	r0, [r7, #4]
 800919e:	f000 f826 	bl	80091ee <USART_ApplicationEventCallback>
		}

		if(temp1 & ( 1 << 2) )
 80091a2:	697b      	ldr	r3, [r7, #20]
 80091a4:	f003 0304 	and.w	r3, r3, #4
 80091a8:	2b00      	cmp	r3, #0
 80091aa:	d00b      	beq.n	80091c4 <USART_IRQHandling+0x37c>
		{
			pUSARTHandle->pUSARTx->ICR |= (1 <<2);
 80091ac:	687b      	ldr	r3, [r7, #4]
 80091ae:	681b      	ldr	r3, [r3, #0]
 80091b0:	6a1a      	ldr	r2, [r3, #32]
 80091b2:	687b      	ldr	r3, [r7, #4]
 80091b4:	681b      	ldr	r3, [r3, #0]
 80091b6:	f042 0204 	orr.w	r2, r2, #4
 80091ba:	621a      	str	r2, [r3, #32]
			USART_ApplicationEventCallback(pUSARTHandle,USART_ERR_NE);
 80091bc:	2106      	movs	r1, #6
 80091be:	6878      	ldr	r0, [r7, #4]
 80091c0:	f000 f815 	bl	80091ee <USART_ApplicationEventCallback>
		}

		if(temp1 & ( 1 << 3) )
 80091c4:	697b      	ldr	r3, [r7, #20]
 80091c6:	f003 0308 	and.w	r3, r3, #8
 80091ca:	2b00      	cmp	r3, #0
 80091cc:	d00b      	beq.n	80091e6 <USART_IRQHandling+0x39e>
		{
			pUSARTHandle->pUSARTx->ICR |= (1 <<3);
 80091ce:	687b      	ldr	r3, [r7, #4]
 80091d0:	681b      	ldr	r3, [r3, #0]
 80091d2:	6a1a      	ldr	r2, [r3, #32]
 80091d4:	687b      	ldr	r3, [r7, #4]
 80091d6:	681b      	ldr	r3, [r3, #0]
 80091d8:	f042 0208 	orr.w	r2, r2, #8
 80091dc:	621a      	str	r2, [r3, #32]
			USART_ApplicationEventCallback(pUSARTHandle,USART_ERR_ORE);
 80091de:	2107      	movs	r1, #7
 80091e0:	6878      	ldr	r0, [r7, #4]
 80091e2:	f000 f804 	bl	80091ee <USART_ApplicationEventCallback>
		}
	}


}
 80091e6:	bf00      	nop
 80091e8:	3718      	adds	r7, #24
 80091ea:	46bd      	mov	sp, r7
 80091ec:	bd80      	pop	{r7, pc}

080091ee <USART_ApplicationEventCallback>:

__weak void USART_ApplicationEventCallback(USART_Handle_t *pUSARTHandle,uint8_t event)
{
 80091ee:	b480      	push	{r7}
 80091f0:	b083      	sub	sp, #12
 80091f2:	af00      	add	r7, sp, #0
 80091f4:	6078      	str	r0, [r7, #4]
 80091f6:	460b      	mov	r3, r1
 80091f8:	70fb      	strb	r3, [r7, #3]

}
 80091fa:	bf00      	nop
 80091fc:	370c      	adds	r7, #12
 80091fe:	46bd      	mov	sp, r7
 8009200:	bc80      	pop	{r7}
 8009202:	4770      	bx	lr

08009204 <__libc_init_array>:
 8009204:	b570      	push	{r4, r5, r6, lr}
 8009206:	4d0d      	ldr	r5, [pc, #52]	@ (800923c <__libc_init_array+0x38>)
 8009208:	4c0d      	ldr	r4, [pc, #52]	@ (8009240 <__libc_init_array+0x3c>)
 800920a:	1b64      	subs	r4, r4, r5
 800920c:	10a4      	asrs	r4, r4, #2
 800920e:	2600      	movs	r6, #0
 8009210:	42a6      	cmp	r6, r4
 8009212:	d109      	bne.n	8009228 <__libc_init_array+0x24>
 8009214:	4d0b      	ldr	r5, [pc, #44]	@ (8009244 <__libc_init_array+0x40>)
 8009216:	4c0c      	ldr	r4, [pc, #48]	@ (8009248 <__libc_init_array+0x44>)
 8009218:	f000 f818 	bl	800924c <_init>
 800921c:	1b64      	subs	r4, r4, r5
 800921e:	10a4      	asrs	r4, r4, #2
 8009220:	2600      	movs	r6, #0
 8009222:	42a6      	cmp	r6, r4
 8009224:	d105      	bne.n	8009232 <__libc_init_array+0x2e>
 8009226:	bd70      	pop	{r4, r5, r6, pc}
 8009228:	f855 3b04 	ldr.w	r3, [r5], #4
 800922c:	4798      	blx	r3
 800922e:	3601      	adds	r6, #1
 8009230:	e7ee      	b.n	8009210 <__libc_init_array+0xc>
 8009232:	f855 3b04 	ldr.w	r3, [r5], #4
 8009236:	4798      	blx	r3
 8009238:	3601      	adds	r6, #1
 800923a:	e7f2      	b.n	8009222 <__libc_init_array+0x1e>
 800923c:	0800926c 	.word	0x0800926c
 8009240:	0800926c 	.word	0x0800926c
 8009244:	0800926c 	.word	0x0800926c
 8009248:	08009270 	.word	0x08009270

0800924c <_init>:
 800924c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800924e:	bf00      	nop
 8009250:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009252:	bc08      	pop	{r3}
 8009254:	469e      	mov	lr, r3
 8009256:	4770      	bx	lr

08009258 <_fini>:
 8009258:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800925a:	bf00      	nop
 800925c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800925e:	bc08      	pop	{r3}
 8009260:	469e      	mov	lr, r3
 8009262:	4770      	bx	lr
